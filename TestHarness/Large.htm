<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Automating Office 97 and Office 2000</TITLE>
<META NAME="Template" CONTENT="C:\Documents and Settings\mokamo\Application Data\Microsoft\Templates\PSS_White_Paper_Template.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc385821906"><A NAME="_Toc473401047">Introduction</A></A></P>
</FONT><I><FONT FACE="Arial" SIZE=2><P><A NAME="_Toc385398929">Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867038"><A NAME="_Toc473401048">Office object models</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867039"><A NAME="_Toc473401049">Objects, Methods, and Properties</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867040"><A NAME="_Toc473401050">Type Libraries</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867041"><A NAME="_Toc473401051">Object Browser</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867042"><A NAME="_Toc473401052">OLE/COM Object Viewer</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867043"><A NAME="_Toc473401053">Where to Find the Object Model Documentation</A> </A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867044"><A NAME="_Toc473401054">How to Use the Object Model Documentation</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867045"><A NAME="_Toc473401055">Exercise 1: Determining Which Classes, Methods, and Properties to Use</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867046"><A NAME="_Toc473401056">PROGIDs and CLSIDs</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867047"><A NAME="_Toc473401057">How an Object Exposes Its Methods and Properties</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867048"><A NAME="_Toc473401058">The Dispatch Interface</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867049"><A NAME="_Toc473401059">Virtual Function Table (vtable)</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867050"><A NAME="_Toc473401060">Creating an Automation client with visual basic</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867051"><A NAME="_Toc473401061">Binding</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc473401062">Early Binding</A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867052"><A NAME="_Toc473401063">Late Binding</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867054"><A NAME="_Toc473401064">Choosing the Correct Type of Binding for Your Automation Client</A> </A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867055"><A NAME="_Toc473401065">Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding</A></A> </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867056"><A NAME="_Toc473401066">Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867057"><A NAME="_Toc473401067">Automating a Running Instance of an Office Application</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867058"><A NAME="_Toc473401068"><A NAME="_CReating_an_Automation"></A>CReating an Automation client with c++</A></A></P>
<P><A NAME="_Toc471867059"><A NAME="_Toc473401069">The IUnknown and IDispatch Interfaces</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867060"><A NAME="_Toc473401070">Passing Parameters and Receiving Return Values</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867061"><A NAME="_Toc473401071">Using the BSTR String Type</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867062"><A NAME="_Toc473401072">Using SAFEARRAYs</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867063"><A NAME="_Toc473401073">Exercise 4: Creating an Automation Client with C/C++</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867064"><A NAME="_Toc473401074">Passing Optional Arguments to Methods</A></A></P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867065"><A NAME="_Toc473401075">Special Case for Property Put Functions</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867066"><A NAME="_Toc473401076">Error Handling</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867067"><A NAME="_Toc473401077">Exercise 5: Implementing an Error Handler for Your Client</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867068"><A NAME="_Toc473401078">Automate a Running Instance of an Office Application</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867069"><A NAME="_Toc473401079">Creating an Automation client with MFC</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867070"><A NAME="_Toc473401080">The COleDispatchDriver Class</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867071"><A NAME="_Toc473401081">Exercise 6: Creating an Automation Client with MFC</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867072"><A NAME="_Toc473401082">Exception Handling</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc473401083">Exercise 7: Implement Exception Handling in Your Automation Client</A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867074"><A NAME="_Toc473401084"><A NAME="_Improving_the_Performance"></A>Improving the Performance of Your Automation Code</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867075"><A NAME="_Toc473401085">Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867076"><A NAME="_Toc473401086">Tip #2 – Minimize the Server's Screen Repaints</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867077"><A NAME="_Toc473401087">Tip #3 – Use Arrays</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867078"><A NAME="_Toc473401088"><A NAME="_Tip_#4_–"></A>Tip #4 – Use the Features of the Automation Server to Your Benefit</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867079"><A NAME="_Toc473401089"><A NAME="_Tip_#5_–"></A>Tip #5 – Minimize Interface Requests</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867080"><A NAME="_Toc473401090">Windows 95/98 Limitation on Interface Requests</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867081"><A NAME="_Toc473401091">Handling events in the Automation server</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867082"><A NAME="_Toc473401092">Using WithEvents in Visual Basic</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867083"><A NAME="_Toc473401093">Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</A></A></P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867084"><A NAME="_Toc473401094">Using Connection Points with C++ and MFC</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867085"><A NAME="_Toc473401095">Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867086"><A NAME="_Toc473401096">Automating Embedded and Linked Office Documents</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867087"><A NAME="_Toc473401097">Using the OLE Container in Visual Basic</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867088"><A NAME="_Toc473401098">Exercise 10: Embed and Automate an Excel Chart with Visual Basic</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867089"><A NAME="_Toc473401099">Use COleClientItem with MFC</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867090"><A NAME="_Toc473401100">Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867091"><A NAME="_Toc473401101">Sample Code for automating Microsoft Office Applications</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867092"><A NAME="_Toc473401102"><A NAME="_Automate_Excel_to"></A>Automate Excel to Create and Format a New Workbook</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867093"><A NAME="_Toc473401103">Visual Basic Example</A></A></P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P><A NAME="_Toc471867094"><A NAME="_Toc473401104">MFC Example</A></A></P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P><A NAME="_Toc471867095"><A NAME="_Toc473401105">Additional Notes</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867096"><A NAME="_Toc473401106">Automate Excel to Add Data from a DAO Recordset to a Workbook</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867097"><A NAME="_Toc473401107">Visual Basic Example</A></A></P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867098"><A NAME="_Toc473401108">MFC Example</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867099"><A NAME="_Toc473401109">Additional Notes</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867100"><A NAME="_Toc473401110">Automate Word to Perform a Mail Merge with Access Data</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867101"><A NAME="_Toc473401111">Visual Basic Example</A></A></P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867102"><A NAME="_Toc473401112">MFC Example</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867103"><A NAME="_Toc473401113">Automate PowerPoint to Create and Run a Slide Show</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867104"></P>
<P><A NAME="_Toc473401114">Visual Basic Example</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867105"><A NAME="_Toc473401115">MFC Example</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867106"><A NAME="_Toc473401116">Automate an Office Application to Obtain a Document's Properties</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867107"><A NAME="_Toc473401117">Visual Basic Sample</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P><A NAME="_Toc471867108"><A NAME="_Toc473401118">MFC Sample</A></A></P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P><A NAME="_Toc471867109"><A NAME="_Toc473401119">Additional Notes for Working with Office Document Properties</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867110"><A NAME="_Toc473401120">Troubleshooting Common problems</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P><A NAME="_Toc471867111"><A NAME="_Toc473401121">For More Information</A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2><P></A></P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><IMG SRC="Image1.gif" WIDTH=611 HEIGHT=25></P>
</FONT><FONT FACE="Arial Black" SIZE=7><P>Automating Microsoft Office 97 and Office 2000</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
<P>Microsoft Product Support Services White Paper</P>
</B><P>Written by Lori Turner</P>
<P>Published on February 17, 2000</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Abstract</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P>This document provides the fundamentals for understanding how to automate Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 97 and Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Office 2000 applications.  This document starts with the basics and walks you through creating a variety of fully functional Automation clients. It is structured as a tutorial with a large assortment of sample code and provides tips throughout that will facilitate development of your Automation clients. Exercises and sample code are presented for Microsoft<FONT FACE="Symbol">&#210;</FONT>
 Visual Basic<FONT FACE="Symbol">&#210;</FONT>
, Microsoft C/C++, and Microsoft Foundation Classes (MFC) developers. However, much of the information is generic (not language-specific) so you can apply it regardless of the development language you use.</P>
</FONT><FONT FACE="Arial" SIZE=2><DIR>
<DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><I><FONT FACE="Arial" SIZE=1><P>&copy; 1999 Microsoft Corporation. All rights reserved.</P>
<P>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</P>
<P>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</P>
<P>Microsoft, Visual Basic, Visual C++, Visual J++, Outlook, and PowerPoint are either registered trademarks or trademarks of Microsoft Corporation in the United States  and other countries.</P>
<P>Other product or company names mentioned herein may be the trademarks of their respective owners.</P>
<P>Microsoft Corporation • One Microsoft Way • Redmond, WA 98052-6399 • USA</P>
<P>0X97&#9;Part no. 098-XXXXX</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>
</DIR>

</I></FONT><FONT FACE="Arial Black" SIZE=3><P>Contents</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401047"><FONT FACE="Arial Black" SIZE=2>Introduction&#9;</FONT><A HREF="#_Toc473401047">*</A></A>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401048"><FONT FACE="Arial Black" SIZE=2>Office object models&#9;</FONT><A HREF="#_Toc473401048">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401049"><B><FONT FACE="Arial" SIZE=2>Objects, Methods, and Properties&#9;</B></FONT><A HREF="#_Toc473401049">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401050"><B><FONT FACE="Arial" SIZE=2>Type Libraries&#9;</B></FONT><A HREF="#_Toc473401050">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401051"><FONT FACE="Arial" SIZE=2>Object Browser&#9;</FONT><A HREF="#_Toc473401051">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401052"><FONT FACE="Arial" SIZE=2>OLE/COM Object Viewer&#9;</FONT><A HREF="#_Toc473401052">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401053"><B><FONT FACE="Arial" SIZE=2>Where to Find the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401053">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401054"><B><FONT FACE="Arial" SIZE=2>How to Use the Object Model Documentation&#9;</B></FONT><A HREF="#_Toc473401054">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401055"><B><FONT FACE="Arial" SIZE=2>Exercise 1: Determining Which Classes, Methods, and Properties to Use&#9;</B></FONT><A HREF="#_Toc473401055">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401056"><B><FONT FACE="Arial" SIZE=2>PROGIDs and CLSIDs&#9;</B></FONT><A HREF="#_Toc473401056">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401057"><FONT FACE="Arial Black" SIZE=2>How an Object Exposes Its Methods and Properties&#9;</FONT><A HREF="#_Toc473401057">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401058"><B><FONT FACE="Arial" SIZE=2>The Dispatch Interface&#9;</B></FONT><A HREF="#_Toc473401058">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401059"><B><FONT FACE="Arial" SIZE=2>Virtual Function Table (vtable)&#9;</B></FONT><A HREF="#_Toc473401059">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401060"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with visual basic&#9;</FONT><A HREF="#_Toc473401060">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401061"><B><FONT FACE="Arial" SIZE=2>Binding&#9;</B></FONT><A HREF="#_Toc473401061">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401062"><B><FONT FACE="Arial" SIZE=2>Early Binding</FONT><FONT FACE="Arial" SIZE=2>&#9;</B></FONT><A HREF="#_Toc473401062">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401063"><FONT FACE="Arial" SIZE=2>Late Binding&#9;</FONT><A HREF="#_Toc473401063">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401064"><FONT FACE="Arial" SIZE=2>Choosing the Correct Type of Binding for Your Automation Client&#9;</FONT><A HREF="#_Toc473401064">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401065"><B><FONT FACE="Arial" SIZE=2>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding&#9;</B></FONT><A HREF="#_Toc473401065">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401066"><B><FONT FACE="Arial" SIZE=2>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding&#9;</B></FONT><A HREF="#_Toc473401066">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401067"><B><FONT FACE="Arial" SIZE=2>Automating a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401067">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401068"><FONT FACE="Arial Black" SIZE=2>CReating an Automation client with c++&#9;</FONT><A HREF="#_Toc473401068">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401069"><B><FONT FACE="Arial" SIZE=2>The IUnknown and IDispatch Interfaces&#9;</B></FONT><A HREF="#_Toc473401069">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401070"><B><FONT FACE="Arial" SIZE=2>Passing Parameters and Receiving Return Values&#9;</B></FONT><A HREF="#_Toc473401070">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401071"><FONT FACE="Arial" SIZE=2>Using the BSTR String Type&#9;</FONT><A HREF="#_Toc473401071">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401072"><FONT FACE="Arial" SIZE=2>Using SAFEARRAYs&#9;</FONT><A HREF="#_Toc473401072">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401073"><B><FONT FACE="Arial" SIZE=2>Exercise 4: Creating an Automation Client with C/C++&#9;</B></FONT><A HREF="#_Toc473401073">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401074"><B><FONT FACE="Arial" SIZE=2>Passing Optional Arguments to Methods&#9;</B></FONT><A HREF="#_Toc473401074">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401075"><B><FONT FACE="Arial" SIZE=2>Special Case for Property Put Functions&#9;</B></FONT><A HREF="#_Toc473401075">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401076"><B><FONT FACE="Arial" SIZE=2>Error Handling&#9;</B></FONT><A HREF="#_Toc473401076">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401077"><FONT FACE="Arial" SIZE=2>Exercise 5: Implementing an Error Handler for Your Client&#9;</FONT><A HREF="#_Toc473401077">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401078"><B><FONT FACE="Arial" SIZE=2>Automate a Running Instance of an Office Application&#9;</B></FONT><A HREF="#_Toc473401078">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401079"><FONT FACE="Arial Black" SIZE=2>Creating an Automation client with MFC&#9;</FONT><A HREF="#_Toc473401079">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401080"><B><FONT FACE="Arial" SIZE=2>The COleDispatchDriver Class&#9;</B></FONT><A HREF="#_Toc473401080">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401081"><B><FONT FACE="Arial" SIZE=2>Exercise 6: Creating an Automation Client with MFC&#9;</B></FONT><A HREF="#_Toc473401081">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401082"><B><FONT FACE="Arial" SIZE=2>Exception Handling&#9;</B></FONT><A HREF="#_Toc473401082">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401083"><FONT FACE="Arial" SIZE=2>Exercise 7: Implement Exception Handling in Your Automation Client&#9;</FONT><A HREF="#_Toc473401083">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401084"><FONT FACE="Arial Black" SIZE=2>Improving the Performance of Your Automation Code&#9;</FONT><A HREF="#_Toc473401084">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401085"><B><FONT FACE="Arial" SIZE=2>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible&#9;</B></FONT><A HREF="#_Toc473401085">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401086"><B><FONT FACE="Arial" SIZE=2>Tip #2 – Minimize the Server's Screen Repaints&#9;</B></FONT><A HREF="#_Toc473401086">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401087"><B><FONT FACE="Arial" SIZE=2>Tip #3 – Use Arrays&#9;</B></FONT><A HREF="#_Toc473401087">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401088"><B><FONT FACE="Arial" SIZE=2>Tip #4 – Use the Features of the Automation Server to Your Benefit&#9;</B></FONT><A HREF="#_Toc473401088">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401089"><B><FONT FACE="Arial" SIZE=2>Tip #5 – Minimize Interface Requests&#9;</B></FONT><A HREF="#_Toc473401089">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401090"><FONT FACE="Arial" SIZE=2>Windows 95/98 Limitation on Interface Requests&#9;</FONT><A HREF="#_Toc473401090">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401091"><FONT FACE="Arial Black" SIZE=2>Handling events in the Automation server&#9;</FONT><A HREF="#_Toc473401091">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401092"><B><FONT FACE="Arial" SIZE=2>Using WithEvents in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401092">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401093"><FONT FACE="Arial" SIZE=2>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401093">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401094"><B><FONT FACE="Arial" SIZE=2>Using Connection Points with C++ and MFC&#9;</B></FONT><A HREF="#_Toc473401094">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401095"><FONT FACE="Arial" SIZE=2>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event&#9;</FONT><A HREF="#_Toc473401095">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401096"><FONT FACE="Arial Black" SIZE=2>Automating Embedded and Linked Office Documents&#9;</FONT><A HREF="#_Toc473401096">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401097"><B><FONT FACE="Arial" SIZE=2>Using the OLE Container in Visual Basic&#9;</B></FONT><A HREF="#_Toc473401097">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401098"><FONT FACE="Arial" SIZE=2>Exercise 10: Embed and Automate an Excel Chart with Visual Basic&#9;</FONT><A HREF="#_Toc473401098">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401099"><B><FONT FACE="Arial" SIZE=2>Use COleClientItem with MFC&#9;</B></FONT><A HREF="#_Toc473401099">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401100"><FONT FACE="Arial" SIZE=2>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart&#9;</FONT><A HREF="#_Toc473401100">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401101"><FONT FACE="Arial Black" SIZE=2>Sample Code for automating Microsoft Office Applications&#9;</FONT><A HREF="#_Toc473401101">*</A></A></P>
<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401102"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Create and Format a New Workbook&#9;</B></FONT><A HREF="#_Toc473401102">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401103"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401103">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401104"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401104">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401105"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401105">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401106"><B><FONT FACE="Arial" SIZE=2>Automate Excel to Add Data from a DAO Recordset to a Workbook&#9;</B></FONT><A HREF="#_Toc473401106">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401107"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401107">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401108"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401108">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401109"><FONT FACE="Arial" SIZE=2>Additional Notes&#9;</FONT><A HREF="#_Toc473401109">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401110"><B><FONT FACE="Arial" SIZE=2>Automate Word to Perform a Mail Merge with Access Data&#9;</B></FONT><A HREF="#_Toc473401110">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401111"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401111">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401112"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401112">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401113"><B><FONT FACE="Arial" SIZE=2>Automate PowerPoint to Create and Run a Slide Show&#9;</B></FONT><A HREF="#_Toc473401113">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401114"><FONT FACE="Arial" SIZE=2>Visual Basic Example&#9;</FONT><A HREF="#_Toc473401114">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401115"><FONT FACE="Arial" SIZE=2>MFC Example&#9;</FONT><A HREF="#_Toc473401115">*</A></A></P></DIR>

<B><FONT FACE="Arial" SIZE=2><P></B></FONT><A HREF="#_Toc473401116"><B><FONT FACE="Arial" SIZE=2>Automate an Office Application to Obtain a Document's Properties&#9;</B></FONT><A HREF="#_Toc473401116">*</A></A></P><DIR>

<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401117"><FONT FACE="Arial" SIZE=2>Visual Basic Sample&#9;</FONT><A HREF="#_Toc473401117">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401118"><FONT FACE="Arial" SIZE=2>MFC Sample&#9;</FONT><A HREF="#_Toc473401118">*</A></A></P>
<FONT FACE="Arial" SIZE=2><P></FONT><A HREF="#_Toc473401119"><FONT FACE="Arial" SIZE=2>Additional Notes for Working with Office Document Properties&#9;</FONT><A HREF="#_Toc473401119">*</A></A></P></DIR>

<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401120"><FONT FACE="Arial Black" SIZE=2>Troubleshooting Common problems&#9;</FONT><A HREF="#_Toc473401120">*</A></A></P>
<FONT FACE="Arial Black" SIZE=2><P></FONT><A HREF="#_Toc473401121"><FONT FACE="Arial Black" SIZE=2>For More Information&#9;</FONT><A HREF="#_Toc473401121">*</A></A></P>
<FONT FACE="Arial" SIZE=2></P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Introduction</P>
</FONT><I><FONT FACE="Arial" SIZE=2><P>Automation</I>, formerly called "OLE Automation," is a technology that allows you to take advantage of an existing program's content and functionality, and to incorporate it into your own applications. Automation is based on the <I>Component Object Model</I> (COM). COM is a standard software architecture based on interfaces that is designed to separate code into self-contained objects, or components. Each component exposes a set of interfaces through which all communication to the component is handled.</P>
<P>With Automation, you can use the Microsoft Word mail merge feature to generate form letters from data in a database without the user being aware that Word is involved. You could even use all of the charting and data analysis functionality that Microsoft Excel provides using Automation. You don’t need to write your own calculation engine to provide the multitude of mathematical, financial, and engineering functions that Excel provides; Instead, you can automate Microsoft Excel to "borrow" this functionality and incorporate it into your own application.</P>
<P>Automation consists of a <I>client </I>and a<I> server.</I> The Automation client attaches to the Automation server so that it can use the content and functionality that the Automation server provides.  The terms <I>client</I> and <I>server</I> are mentioned frequently throughout this document, so it is important that you understand their relationship. </P>
<P>This document is intended to provide you with a foundation for developing your own Automation clients for Microsoft Office applications. In this document, a hands-on approach is used to help you to do the following:</P>

<UL>
<LI>Understand how Office applications expose their content and functionality to Automation clients.</LI>
<LI>Identify the specific functions for the task you choose to Automate.</LI>
<LI>Locate the resources and documentation you need.</LI>
<LI>Understand how Automation works behind the scenes.</LI>
<LI>Create Automation clients with Visual Basic, Visual C++<FONT FACE="Symbol">&#210;</FONT>
, and MFC.</LI>
<LI>Develop a controller that uses the server as efficiently as possible.</LI></UL>

<P>All of the Microsoft Office applications have their own scripting language, which can be used to perform tasks within the applications. This scripting language is Microsoft Visual Basic for Applications (VBA). The set of functions that a Visual Basic for Applications routine, or <I>macro,</I> can use to control its host application is the same set of functions that the Automation client can use to control the application externally, regardless of the programming language for the controller. Understandably, the Office applications provide documentation on their scripting functions in a syntax that is easily interpreted by the Visual Basic for Applications programmer. So, if you choose to write your controller in another programming language, such as Visual C++, Microsoft Foundation Classes (MFC), or Microsoft Visual J++<FONT FACE="Symbol">&#210;</FONT>
, you must translate the Visual Basic for Applications syntax of Office functions so that you can apply it to the programming language you choose for your controller. </P>
<P>This document is structured as a tutorial and consists of a series of discussions and exercises. For the exercises, you need the following:</P>

<UL>
<LI>Microsoft Office 97 or 2000</LI>
<LI>Microsoft Visual Basic 5.0 or 6.0</LI>
<LI>Microsoft Visual C++ 5.0 or 6.0</LI></UL>

<P>You can use the steps and code in each exercise to create a complete and functional application. If you run into problems during an exercise, you can refer to the samples included with this document. The projects for the exercises and samples are outlined below.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Exercise / Sample</B></FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Location</B></FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 2</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise2</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 3</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise3</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Using SAFEARRAYs</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\SafeArrayDemo</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 4</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise4</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 5</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\C++\Exercise5</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 6</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise6</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 7</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise7</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 8</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise8</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 9</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise9</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 10</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\Exercise10</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Exercise 11</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\MFC\Exercise11</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Create and Format a New Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelArray<BR>
..\MFC\ExcelArrays</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\ExcelData<BR>
..\MFC\ExcelData</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate Word to Perform a Mail Merge with Access Data</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\MailMerge<BR>
..\MFC\MailMerge</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate PowerPoint to Create and Run a SlideShow</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\SlideShow<BR>
..\MFC\SlideShow</FONT></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Automate an Office Application to Obtain a Document's Properties</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>..\VB\DocProps<BR>
..\MFC\DocProps</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Office object models</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications expose their functionality as a set of programmable <I>objects.</I> Every unit of content and functionality in Office is an object that you can programmatically examine and control. A workbook, a document, a table, a cell, and a paragraph are all examples of objects that are exposed by Microsoft Office applications.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Objects, Methods, and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Objects for each of the Microsoft Office applications are arranged hierarchically, similar to a family tree, in what is called an <I>object model</I>. Each object model has an uppermost object from which all other objects are derived. This uppermost object usually represents the Office application itself, and is appropriately named the <B>Application</B> object. The <B>Application</B> object has child objects, which, in turn, have child objects of their own.</P>
<P>To visualize this idea of object hierarchy, you can examine some of the objects exposed by Microsoft Excel. Figure 1 is a graphical representation of a small fragment of the Excel object model.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 1:    This diagram represents just a small portion of the Excel object model and it portrays the parent-child relationships of the objects.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, the uppermost object in the Excel object model is the <B>Application</B> object. The Excel <B>Application</B> object has many children, two of which are <B>Workbooks</B> and <B>CommandBars</B>. <B>Workbooks</B> and <B>CommandBars</B> are <I>collection objects</I> that contain other objects. A <B>Workbooks</B> collection object contains <B>Workbook</B> objects and a <B>CommandBars</B> collection object contains <B>CommandBar</B> objects. A <B>Workbook</B> has many children of its own, two of which are the <B>Worksheets</B> collection object and the <B>Charts</B> collection object. A <B>Worksheet </B>object has many children of its own as well, including the <B>Range</B> object and the <B>Shapes</B> collection object. The list goes on, but this should be enough to help you understand how object models are organized hierarchically. Understanding the relationships between objects is fundamental to automating Office applications.</P>
<P>An object by itself does nothing unless you can do something with that object. To programmatically examine or control an object, you can use the properties and methods that the object supports. A <I>property</I> is a function that sets or retrieves an attribute for an object. A <I>method</I> is a function that performs some action on an object.</P>
<P>Once again, look at the Excel object model to get an idea of what is considered a <I>property</I> and what is considered a <I>method</I>. Excel exposes a <B>Range</B> object that represents a range of one or more cells on a worksheet. A <B>Range</B> object has attributes that describe its contents, number format, and font. These attributes can all be determined by inspecting <I>properties</I> of the <B>Range</B> object: the <B>Value</B> property, the <B>NumberFormat</B> property, and the <B>Font</B> property, respectively. There are actions that you can make on a <B>Range</B> object; you can select it, delete it, and copy it. These actions represent <I>methods</I> of the <B>Range</B> object; the <B>Select</B> method, the <B>Delete</B> method, and the <B>Copy</B> method.</P>
<P>In Visual Basic, you navigate to an object by starting at the uppermost object and working your way down to your target. Consider the <B>Workbooks</B> collection object, which represents all the open workbooks in the Excel application. You could use its <B>Count</B> property to acquire the count of workbooks open in Excel:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>i =  Application.Workbooks.Count</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For another example, consider the <B>Range</B> object. To navigate to a <B>Range</B> object, you would start at the Application object and work your way down. The following code returns the value of cell A1 on Sheet1 in a workbook named Book1.xls: </P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks("Book1.xls").Worksheets("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Note that Workbooks("Book1.xls") returns a single <B>Workbook</B> object from the <B>Workbooks</B> collection. Another way that you can return a single object from a collection is to use the <B>Item</B> property for the collection. You could use the following code to achieve the same results:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>x= Application.Workbooks.Item("Book1.xls"). _<BR>
                      Worksheets.Item("Sheet1").Range("A1").Value</P>

</FONT><FONT FACE="Arial" SIZE=2><P>For simplicity, Visual Basic programmers typically use the shorter form and omit the <B>Item</B> property when obtaining a single object from a collection. However, as the sample code presented in this document will illustrate, the <B>Item</B> property is important for C/C++ programmers because it must be explicitly called to obtain a single object from a collection.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Type Libraries</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A type library is a file or part of a file that provides information about the functionality of a COM object. More specifically, the type library contains information about <I>classes</I>. A <I>class</I> is a description of an <I>object</I>. Type libraries themselves do not store actual objects; they only store information about those objects. </P>
<P>A type library specifies all the information an Automation client needs to call a method or property for an object. For properties, the type library describes the value it accepts or returns. For methods, the type library provides a list of all the arguments the method can accept, tells you the data type of each argument, and indicates whether an argument is required.</P>
<P>Type libraries can appear in any of the following forms:</P>

<UL>
<LI>A resource in a .dll file</LI>
<LI>A resource in an .exe file</LI>
<LI>A stand-alone type library file (.tlb)</LI></UL>

<P>Each Microsoft Office application provides multiple type library resources in a single .dll file. A .dll file with multiple type library resources is typically called an <I>object library</I> (.olb). The following table lists the file names for Microsoft Office 97 and Office 2000 type libraries. The type library for each application can be found in the same folder as the application's .exe file. </P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0)</B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msacc9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Graph9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl8.olb<BR>
<B>Note</B><I>: </I>Use Msoutl85.olb for Outlook 98</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msoutl9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint<FONT FACE="Symbol">&#210;</FONT>
</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msppt9.olb</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword8.olb</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Msword9.olb</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Object Browser</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In Visual Basic and in the Visual Basic Editor of Office applications, you can use the Object Browser to view a type library. To display the Object Browser, press F2 or click <B>Object Browser</B> on the <B>View</B> menu.</P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 2:   The Object Browser provides information about the classes, methods, and properties a COM object exposes.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Object Browser in Figure 2 displays all of the objects that the Microsoft Word type library exposes. When you select a class, all of its properties and methods (or class members) are provided in a list. When you select a property or method, the syntax for the item you have selected appears in the bottom pane of the Object Browser.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>OLE/COM Object Viewer</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To view type library information, you can also use the OLE/COM Object Viewer utility that is included with Microsoft Visual Studio<FONT FACE="Symbol">&#210;</FONT>
. Like the Object Browser that Visual Basic and Microsoft Visual Basic for Applications use, the OLE/COM Object Viewer lists all the classes exposed in a type library, along with the methods and properties those classes support. For the C++ programmer, the OLE/COM Object Viewer provides important information, such as function return types, argument types, and DISPIDs (which will be discussed shortly). You can use the information that the viewer provides in conjunction with the Office object model documentation. </P>
<P>To view a type library with the OLE/COM Object Viewer:</P></DIR>

<OL>

<OL>

<LI>In Visual C++, on the <B>Tools</B> menu, click <B>OLE/COM Object Viewer</B>. </LI>
<LI>On the <B>File </B>menu, click <B>View TypeLib</B>, and browse to locate the type library you want to view.</LI></OL>
</OL>
<DIR>

<P>The OLE/COM Object Viewer illustrated in Figure 3 displays information from the Microsoft Word 97 type library. More specifically, it shows the details for the <B>Add </B>member function of the <B>Documents </B>class. </P>

<P>&nbsp;</P></DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 3:   Use the OLE/COM Object Viewer to view class information in a type library.</P>
</B></FONT><FONT FACE="Arial Black" SIZE=3><P>Where to Find the Object Model Documentation </P>
</FONT><FONT FACE="Arial" SIZE=2><P>The object models for the Office applications are documented in the language reference for both versions of Office:</P><DIR>
<DIR>

<I><P>Microsoft Office 97 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-339-0</P>
<I><P>Microsoft Office 2000 Visual Basic for Applications Language Reference <BR>
</I>ISBN 1-57231-955-0</P></DIR>
</DIR>

<P>The language references are available on MSDN and in the Help files that are included with Microsoft Office. They can also be purchased in printed form. For ordering information, please visit </FONT><A HREF="http://mspress.microsoft.com/"><FONT FACE="Arial" SIZE=2>http://mspress.microsoft.com</FONT></A><FONT FACE="Arial" SIZE=2>.</P>
<P>The following table lists the Help files for each Office application.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 97 (or 8.0)</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Version 2000 (or 9.0) </B></FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acvba80.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Acmain9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaxl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp8.hlp </FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbagrp9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Office</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoff9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbaoutl9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbappt9.chm</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd8.hlp</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Vbawrd9.chm</FONT></TD>
</TR>
</TABLE>

<B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER"></P>
</B><P>The Help files that are included with Microsoft Office 97 are installed by default in the C:\Program Files\Microsoft Office\Office folder. If you cannot find the Office 97 Visual Basic for Applications Help file you need, it probably was not installed when you initially ran Office 97 Setup. To install the Help file, run Office Setup to add the Visual Basic for Applications Help file. Note that Office Setup does not install the Outlook 97 Visual Basic for Applications Help file. For information on installing the Outlook 97 Visual Basic for Applications Help file, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q166738 OL97: How to Install Visual Basic Help<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q166/7/38.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q166/7/38.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>The Help files that are included with Microsoft Office 2000 are installed by default in the C:\Program Files\Microsoft Office\Office\1033 folder. Microsoft Office 2000 Setup will install the Visual Basic for Applications Help files "on first use." Therefore, you might not see the Help file in this folder if you have not previously attempted to access Visual Basic for Applications Help in the Office application.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>How to Use the Object Model Documentation</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are several methods you can use to find documentation for a specific class, method, or property:</P>

<UL>
<B><LI>Search the Visual Basic for Applications Help file.</B><BR>
In the Visual Basic Editor for the Office application, click <B>Contents</B> <B>and</B> <B>Index </B>on the <B>Help</B> menu. On the <B>Contents</B> tab, select the language reference you want and click <B>Display</B>. Visual Basic for Applications Help for the language reference you selected appears. At this point, you can use either the <B>Index</B> or the <B>Find</B> tab to locate information on a specific class, method, or property.</LI>
<B><LI>Use Context Sensitive Help in a module or in the Immediate Window.</B><BR>
In the Visual Basic Editor for the Office application, type the class, method, or property in the code window of a module or in the Immediate Window. Select the text and press F1. The Help topic for the item appears. </LI>
<B><LI>Use the Object Browser.</B><BR>
Press F2 in the Visual Basic Editor for the Office application to display the Object  Browser. The Object Browser lists all of the objects that the application exposes and, for each object, it lists its methods, properties, and events. To view Help on a specific class or class member, select it in the Object Browser and press F1.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 1: Determining Which Classes, Methods, and Properties to Use</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are not already familiar with the object model of the application you intend to automate, you can use the application's macro recorder to get an idea of where you should begin. To illustrate, suppose you want to automate Microsoft Word to add some text to a new document and then save the document, but you don't know which methods and properties to use. You can start with the macro recorder:</P>
<OL>

<LI>Start Microsoft Word.</LI>
<LI>On the <B>Tools </B>menu, click <B>Macro</B>, and then select <B>Record New Macro</B>. In the <B>Store Macro In</B> drop-down box, select the name of the active document. Make note of the new macro's name, and then click <B>OK</B> to start recording.</LI>
<LI>Start a new document.</LI>
<LI>Type <B>one</B> and press ENTER.</LI>
<LI>Type <B>two</B> and press ENTER.</LI>
<LI>Type <B>three</B>.</LI>
<LI>On the <B>File</B> menu, click <B>Save</B>, and save the document as C:\doc1.doc. </LI>
<LI>Click the <B>Stop Recording</B> button (or, on the <B>Tools</B> menu, click <B>Macro</B> and then </FONT><FONT FACE="Arial" SIZE=1>click</FONT><FONT FACE="Arial" SIZE=2>click <B>Stop Recording</B>).</LI></OL>

<P>To view the Visual Basic for Applications code that the macro recorder generated from your actions, on the <B>Tools</B> menu, click <B>Macro</B>, and then click <B>Macros</B>. Select the name of the new macro in the list and click <B>Edit</B>. The Visual Basic Editor displays the recorded macro.</P><DIR>

</FONT><FONT FACE="Courier New" SIZE=1><P>    Documents.Add</P>
<P>    Selection.TypeText Text:="one"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="two"</P>
<P>    Selection.TypeParagraph</P>
<P>    Selection.TypeText Text:="three"</P>
<P>    ActiveDocument.SaveAs FileName:="Doc1.doc",<BR>
        FileFormat:=wdFormatDocument, _</P>
<P>        LockComments:=False, Password:="", AddToRecentFiles:=True, <BR>
        WritePassword:="", ReadOnlyRecommended:=False, <BR>
        EmbedTrueTypeFonts:=False, SaveNativePictureFormat:=False, <BR>
        SaveFormsData:=False, SaveAsAOCELetter:= False </P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>

<P>You can benefit from understanding how each class fits within the object model, and from learning the description and type of all parameters for the methods and properties you use for your task.</P>
<P>Start by examining the first line of the recorded macro: <B>Documents.Add</B>. Select <B>Documents</B> in the code module for the recorded macro and press F1. The Help topic provides you with the following important information:</P>

<UL>
<LI>The <B>Documents </B>property returns a <B>Documents </B>collection that represents all of the open documents.</LI>
<LI>The <B>Documents </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, select <B>Add</B> on the code module, and press F1. A Help topic appears explaining that many different objects have an <B>Add</B> method. Click <B>Documents</B> to see the Help for the <B>Add</B> method of the <B>Documents</B> collection. The Help topic provides the following important information:</P>

<UL>
<LI>The <B>Add </B>method adds a new, empty document to the collection of open documents.</LI>
<LI>The <B>Add </B>method can take two arguments, both of which are optional.</LI></UL>

<P>Now examine the next line in the recorded macro: <B>Selection.TypeText Text:="one"</B>. Click <B>Selection</B> in the code module and press F1: </P>

<UL>
<LI>The <B>Selection </B>property returns the <B>Selection</B> object that represents a selected range or the insertion point.</LI>
<LI>The <B>Selection </B>property applies to the <B>Application</B> object.</LI></UL>

<P>Return to the recorded macro, click <B>TypeText</B> on the code module, and press F1:</P>

<UL>
<LI> The <B>TypeText</B> method inserts the specified text.</LI>
<LI>The <B>TypeText</B> method has one required argument of type <B>String</B>.</LI>
<LI>The <B>TypeText</B> method applies to the <B>Selection </B>object.</LI></UL>

<P>Next, see the Help topic for <B>TypeParagraph</B>:</P>

<UL>
<LI>The <B>TypeParagraph </B>method inserts a new blank paragraph.</LI>
<LI>The <B>TypeParagraph </B>method applies to the <B>Selection </B>object and has no arguments.</LI></UL>

<P>Now, examine the Help topics for the <B>ActiveDocument </B>property and the <B>SaveAs </B>method:</P>

<UL>
<LI>The <B>ActiveDocument </B>property returns a <B>Document </B>object that represents the document with the focus. The <B>ActiveDocument </B>property applies to the <B>Application </B>object.</LI>
<LI>The <B>SaveAs </B>method saves a document. This method has eleven arguments, only one of which is required. The <B>SaveAs</B> method applies to a <B>Document </B>object.</LI></UL>

<P>You might have noticed that the <B>Documents </B>property,<B> Selection </B>property, and <B>ActiveDocument </B>property are all properties that apply to the <B>Application </B>object, yet are not qualified with the <B>Application</B> object in the recorded macro. The <B>Application </B>object is the default object for all "unqualified" properties in Word Visual Basic for Applications and can therefore be omitted when writing code in a Word Visual Basic for Applications macro. This is not the case when writing Automation code. As you will see in code samples presented later in this article, all properties and methods should be fully qualified. Failure to fully qualify properties and methods in your Automation client can result in errors and unpredictable results at run time.</P>
<P>Upon examination of the recorded macro, notice that the <B>SaveAs </B>method has an argument for which it passes the built-in constant <B>wdFormatDocument</B>. Depending on the programming language you choose for your Automation client, you might need to pass the numeric value for built-in constants. The Help topic for the <B>SaveAs </B>method does not give you this information, but you can find it in the Object Browser. Press F2 to display the Object Browser. Type <B>wdFormatDocument</B> in the search window and press ENTER. In the bottom pane of the Object Browser, note the numeric equivalent of <B>wdFormatDocument</B> is 0<B> </B>as well as other information about the constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>PROGIDs and CLSIDs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office applications register all of their classes in the Windows system registry. Each class is associated with a <I>globally unique identifier</I> (or GUID) called a <I>class identifier</I>. In the registry, each class identifier (or CLSID) is mapped to a <I>programmatic identifier</I> (or PROGID) and to its application, as shown in Figure 4.</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 4:   The relationship between PROGID, CLSID, and Server as described in the Windows registry</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>When automating an Office application, you can use either the CLSID or the PROGID to create an object from one of the classes that the Office application exposes. The following table lists the most commonly used PROGIDs for Office 97 and Office 2000 applications:</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="35%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Application</B></FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Programmatic Identifier (PROGID)</B></FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Access</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Access.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Excel</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Excel.Application<BR>
Excel.Worksheet<BR>
Excel.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Graph</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>MSGraph.Chart</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Outlook</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Outlook.Application</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft PowerPoint</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>PowerPoint.Application<BR>
PowerPoint.Presentation</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Microsoft Word</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Word.Application<BR>
Word.Document</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>This table provides <I>version-independent</I> PROGIDs. You should note that Office applications have <I>version-dependent </I>PROGIDs as well. For example, Excel 97 has Excel.Application.8 and Excel 2000 has Excel.Application.9. You can use these PROGIDs in your Automation code, but it is recommended that you use the version-independent PROGIDs so that your code can be compatible with multiple versions of the application you automate.</P>

</FONT><FONT FACE="Arial Black" SIZE=3><P>How an Object Exposes Its Methods and Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>All COM objects that can be automated implement a special interface: the <B>IDispatch</B> interface. It is this <B>IDispatch</B> interface that provides Automation clients with access to an object's content and functionality. An object can expose its methods and properties in two ways: by means of a <I>dispatch interface</I> and in its <I>vtable</I>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The Dispatch Interface</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object's methods and properties collectively make up its <I>dispatch</I> <I>interface</I> (or <I>dispinterface</I>). Within the dispinterface, each method and property is identified by a unique member. This member is the function's <I>dispatch identifier</I> (or <I>DispID</I>). </P>

<B><P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=1><P>Figure 5:   An object can provide clients access to its functions using a dispinterface, an array of function names and an array of function pointers that are indexed by DispIDs.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To execute a method or a property of the object portrayed in Figure 5, an Automation client can:</P>
<OL>

<LI>Call <B>GetIDsOfNames</B> to "look up" the DispID for the method or property.</LI>
<LI>Call <B>Invoke</B> to execute the method or property by using the DispID to index the array of function pointers. </LI></OL>
<DIR>

<B><I><P>NOTE</B>: IDispatch and its functions are described in greater detail in this document under </I></FONT><A HREF="#_CReating_an_Automation"><I><FONT FACE="Arial" SIZE=2>"Creating an Automation client with C++."</I></FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Virtual Function Table (vtable)</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The pointer to an interface references a table of pointers to functions that the interface supports. This table is called the <I>virtual function table</I> (or <I>vtable</I>). A COM object can expose its functions in its vtable to provide clients more direct access to the functions. Subsequently, this eliminates the need to call <B>Invoke</B> and <B>GetIDsOfNames</B>. </P>
<P>An object that exposes its methods through both a dispinterface and its vtable supports a <I>dual interface</I>. Figure 6 represents an object that has a dual interface. Clients can either:</P>

<UL>
<LI>Access its functions using <B>GetIDsOfNames</B> and <B>Invoke</B>. </LI></UL>
<DIR>

<P>-or-   </P></DIR>


<UL>
<LI>Access its functions through the vtable. It is up to the Automation client to decide which method it uses to gain access to the object’s functions.</LI></UL>


</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 6:   An object that has a dual interface can provide clients access to its functions with a dispinterface and in its vtable.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>You can examine type libraries in the OLE/COM Object Viewer to determine if an object provides a dual interface. An object that provides a dual interface specifies the dual attribute in its interface declaration. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with visual basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Visual Basic programmers have an advantage when it comes to writing code to automate Office applications in that any Visual Basic for Applications macro can be copied and pasted and, with a few modifications, can become valid Visual Basic Automation code. An important factor determining how your recorded macro code should be modified so that it becomes Automation code is the type of binding you plan to use.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Binding describes how an Automation client internally invokes a given method or property. There are two types of binding: <I>early binding</I> and <I>late binding</I>. With Visual Basic, the type of binding you choose is determined solely by the manner in which you declare your variables.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Early Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With early binding, your project maintains a reference to the Automation server's type library and you declare your variables as types defined by that type library. For example, if your project had a reference to the Microsoft Word type library, you could declare an object variable as shown:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Word.Application</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Because information from the server's type library is available at compile time, Visual Basic does not need to "look up" the property or method at run time. If the object exposes its function in its vtable, Visual Basic uses <I>vtable binding</I> and calls the function through the vtable. If the object does not support vtable binding, Visual Basic invokes the function using the DispId it obtained from the type library. In other words, it uses <I>DispID binding</I>.</P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With late binding in Visual Basic, your project does not need a reference to the Automation server's type library and you can declare your variables as type <B>Object</B>.</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp as Object</P>

</FONT><FONT FACE="Arial" SIZE=2><P>When you declare a variable as type <B>Object</B>, Visual Basic cannot determine at compile time what sort of object reference the variable contains, so binding occurs at run time. When you call a property or method of an object with late binding, the process by which Visual Basic makes the call is twofold:</P></DIR>


<UL>

<UL>
<LI>Using an interface pointer to the object, Visual Basic calls <B>GetIDsOfNames</B> to "look up" the name of that property or method to retrieve its DispID.</LI></UL>
</UL>
<DIR>
<DIR>

<P>-and-</P></DIR>
</DIR>


<UL>

<UL>
<LI>Visual Basic calls <B>Invoke</B> to execute the property or method using the DispID.</LI></UL>
</UL>


</FONT><FONT FACE="Courier New" SIZE=1><P> </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Choosing the Correct Type of Binding for Your Automation Client </P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are advantages to both types of binding. You should weigh the benefits of each before deciding which type of binding you choose for your Automation client.</P>
<P>Early binding provides you with increased performance and compile-time syntax checking. In addition, you receive direct access to the server's type library in the Visual Basic design environment and to the Help for the object model.</P>
<P>Despite the benefits of early binding,  late binding is most advantageous when you are writing Automation clients that you intend to be compatible with future versions of your Automation server. With late binding, information from the server’s type library is not &quot;hard wired&quot; into your client so you can have greater confidence that your Automation client can work with future versions of the Automation server without code changes.</P>
<P>For more information about binding in Visual Basic, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q245115 INFO: Using Early Binding and Late Binding in Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q245/1/15.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q245/1/15.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Exercise 2: Creating a Visual Basic Automation Client that Uses Early Binding </P>
</FONT><FONT FACE="Arial" SIZE=2><P>Earlier, you recorded a macro in Word to perform the simple task of starting a new document, adding text to that document, and saving it. Now you will convert that recorded code to Automation code that uses early binding. Early bound code in Visual Basic is characterized by a reference to the Automation server's type library and variables that are declared as objects that are defined by that type library.</P>
<OL>

<LI>Start a new Standard EXE project in Visual Basic. Form1 is created by default.</LI>
<LI>On the <B>Project</B> menu, click <B>References</B>, and select "Microsoft Word 8.0 Object Library" (or "Microsoft Word 9.0 Object Library" if you are using Word 2000). </LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the Click event of the <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
Dim oWordApp As Word.Application<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = New Word.Application<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=wdFormatDocument, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the program and click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created.</LI></OL>

<P>Compare this Automation code to the macro you recorded in the previous exercise. There are several important differences you should note: </P>

<UL>
<LI>The variable </FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><B><FONT FACE="Arial" SIZE=2>,</B> which contains your reference to the instance of Word, is declared as the type <B>Word.Application</B>. This is what makes the Automation code "early-bound." </LI>
<LI>When Word is started through Automation, it is not visible. Most Automation servers have a <B>Visible</B> property for the <B>Application</B> object that you can set to <B>True</B> if you want to make the server visible at run time.</LI>
<LI>The <B>Documents</B>, <B>Selection,</B> and <B>ActiveDocument</B> properties are now all "qualified" with the reference to the Word Application object (</FONT><FONT FACE="Courier New" SIZE=2>oWordApp</FONT><FONT FACE="Arial" SIZE=2>).  Remember that in a Word Visual Basic for Applications macro, the <B>Application </B>object is assumed and can be omitted. This is not the case when you write Automation code; all properties and methods should be fully qualified. </LI></UL>
<DIR>
<DIR>

<B><P>NOTE</B>: Failure to fully qualify your calls to an Automation server's methods and properties can generate run-time errors or give you unexpected results.</P></DIR>
</DIR>


<UL>
<LI>In the exercise, you added a line to quit the Word application. If you do not call <B>Quit</B>, a "hidden" instance of an Automation server might remain running even after your code ends, and this is almost always undesirable.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 3: Creating a Visual Basic Automation Client that Uses Late Binding</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now you will modify the project you created for early binding to late binding. "Late-bound" Automation code does not require a reference to the server's type library, and the variables are declared as type <B>Object</B>.</P>
<OL>

<LI>On the <B>Project</B> menu, click <B>References</B>, and remove the reference to the Word type library. </LI>
<LI>Modify the code for Form1 so that it is "late-bound." The modified code should appear as follows:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>Dim oWordApp As Object<BR>
<BR>
'Start a new instance of Microsoft Word<BR>
Set oWordApp = CreateObject("Word.Application")<BR>
<BR>
With oWordApp<BR>
<BR>
   'Create a new document<BR>
   .Documents.Add<BR>
<BR>
   'Add text to the document<BR>
   .Selection.TypeText Text:="one"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="two"<BR>
   .Selection.TypeParagraph<BR>
   .Selection.TypeText Text:="three"<BR>
   'Save the document<BR>
   .ActiveDocument.SaveAs FileName:="c:\Doc1.doc", _<BR>
       FileFormat:=0, LockComments:=False, _<BR>
       Password:="", AddToRecentFiles:=True, WritePassword _<BR>
       :="", ReadOnlyRecommended:=False, EmbedTrueTypeFonts:=False, _<BR>
       SaveNativePictureFormat:=False, SaveFormsData:=False, _<BR>
       SaveAsAOCELetter:= False<BR>
<BR>
End With<BR>
<BR>
'Quit Word<BR>
oWordApp.Quit<BR>
<BR>
'Unload this form<BR>
Unload Me </P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Press F5 to run the program and then click the <B>CommandButton</B>. When the program ends, examine the Word document ("C:\doc1.doc") it created. The results are exactly the same as they were with the "early-bound" code.</LI></OL>

<I>
</I><P>Note that in the "late-bound" code that you have replaced the constant <B>wdFormatDocument</B> with its numeric equivalent (0). This is necessary because you removed the reference to the Microsoft Word type library. If you choose to use late binding in your Visual Basic projects, all built-in constants should be replaced with their numeric equivalents, which you can determine using the Object Browser as previously illustrated.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To automate an instance of an Office application that is already running, you can use the <B>GetObject</B> function in a Visual Basic project that uses either early or late binding. In the previous examples for early and late binding, if Word were already running and you wanted to use that running instance for Automation, you would replace the statement that starts a new instance of Word with the following:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>Set oWordApp = GetObject( , "Word.Application")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The remainder of the code could remain the same. Of course, you probably would not want to call the <B>Quit</B> method to quit an instance of Word that the user had possibly established themselves.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>CReating an Automation client with c++</P>
<P>The IUnknown and IDispatch Interfaces</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Interfaces are the cornerstone to COM. An <I>interface</I> is a table of pointers to related functions. Once you acquire a pointer to an interface, you have access to the functions in that interface. The <B>IUnknown</B> and <B>IDispatch</B> interfaces are at the heart of Automation. </P>
<P>All COM interfaces inherit from the <B>IUnknown </B>interface. <B>IUnknown</B> gives COM objects the means to manage their lifetimes and provides clients access to other interfaces that an object supports. The <B>IUnknown</B> interface has only three functions, all of which a COM object must support.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::QueryInterface()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to identify and navigate interfaces that an object supports</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::AddRef()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client makes a request for an interface</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IUnknown::Release()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called each time a client releases an interface</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>Each COM object is responsible for maintaining a count of the number of interface pointers it has handed out to clients by means of <B>AddRef</B> and <B>Release</B>. This count is called the <I>reference count.</I> When the object's reference count goes to zero, this is an indication to the object that there are no clients currently using its interfaces and that it can safely remove itself from memory. As you can imagine, properly maintaining reference counts is very important; if references to objects are not properly released, you risk the chance of leaving an object in memory even when it is no longer in use.</P>
<P>In addition to <B>IUnknown</B>, every COM object that can be automated implements <B>IDispatch</B> because it is <B>IDispatch</B> that gives a client access to the object's properties and methods. The <B>IDispatch</B> interface provides the means for automating COM objects using only four functions.</P>
</FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfoCount()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to determine if type information is available</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetTypeInfo()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to retrieve the type information</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::GetIDsOfNames()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to obtain the DISPID from the name of a property or method</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>IDispatch::Invoke()</B></FONT></TD>
<TD WIDTH="60%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Called to invoke a method or property for the object</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>To begin the Automation process, a client creates an instance of the Automation server by making a call to <B>::CoCreateInstance</B>. With <B>::CoCreateInstance</B>, you provide a CLSID for the Automation server and make a request for the <B>IUnknown</B> interface. (Note that you can determine the CLSID from the ProgID at run time with <B>::CLSIDFromProgID.</B>) Once the pointer to <B>IUnknown</B> is received, the client can then make the call to <B>IUnknown::QueryInterface</B> for a pointer to the object's <B>IDispatch</B> interface. The following code illustrates how an Automation client can create a new instance of Microsoft Word and obtain an <B>IDispatch</B> pointer to Word's Application object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Get the CLSID for Word's Application Object</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>// Create an instance of the Word application and obtain the pointer</P>
<P>// to the application's IUnknown interface</P>
<P>IUnknown* pUnk;</P>
<P>HRESULT hr = ::CoCreateInstance( clsid,</P>
<P>                                 NULL,</P>
<P>                                 CLSCTX_SERVER,</P>
<P>                                 IID_IUnknown,</P>
<P>                                 (void**) &amp;pUnk);</P>

<P>// Query IUnknown to retrieve a pointer to the IDispatch interface</P>
<P>IDispatch* pDispApp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once the client has a pointer to the object's <B>IDispatch</B> interface, it can begin the work of calling the object’s exposed methods and properties. To call methods and properties, it needs their corresponding DISPIDs. The Automation client can call <B>IDispatch::GetIDsOfNames</B> to retrieve a DISPID for a function of the object. Then, with the DISPID in hand, the client can use <B>IDispatch::Invoke</B> to invoke the method or property.</P>
<P>Now consider the <B>IDispatch</B> interface in terms of a C/C++ Automation client that automates Word to create a document similar to that of your Visual Basic Automation client. Figure 7 represents how this Automation client might use the <B>IDispatch</B> interface for the Automation server: </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 7:   A representation of the COM objects that an Automation client might access for Microsoft Word</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>The Automation client represented in Figure 7:</P>

<UL>
<LI>Calls <B>::CoCreateInstance</B> to create a new instance of Microsoft Word and obtains a pointer to the Application object's <B>IUnknown</B> interface, </FONT><FONT FACE="Courier New" SIZE=2>pUnk</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Obtains a pointer to the Application's object's <B>IDispatch</B> interface through a call to <B>IUnknown::QueryInterface</B>. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispApp</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Application's <B>Documents</B> property and receives the DISPID 0x6.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0x6 to get the <B>Documents</B> property. The call to get the <B>Documents</B> property returns a pointer to <B>IDispatch</B> for the <B>Documents</B> collection. This pointer is </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2>.</LI>
<LI>Calls <B>IDispatch::GetIDsOfNames</B> on </FONT><FONT FACE="Courier New" SIZE=2>pDispDocs</FONT><FONT FACE="Arial" SIZE=2> to acquire the DISPID of the Documents' <B>Add</B> method and receives the DISPID 0xb.</LI>
<LI>Calls <B>IDispatch::Invoke</B> with the DISPID 0xb to execute the <B>Add</B> method so that a new document is added in Microsoft Word. </LI>
<LI>Continues in this same manner, making calls to pairs of <B>IDispatch::GetIDsOfNames</B> and <B>IDispatch::Invoke</B>, until the automated task is complete.</LI></UL>

<P>When <B>IDispatch::Invoke</B> is called upon to invoke a method or property, it also<B> </B>passes on parameters for the invoked method or property and receives its return value, if a value is returned. As you can see, <B>IDispatch::Invoke</B> really does most of the work in this process and rightfully deserves a little extra attention. </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>HRESULT Invoke( </P>
<P>  DISPID  dispIdMember,         // DISPID for the member function  </P>
<P>  REFIID  riid,                 // Reserved, must be IID_NULL    </P>
<P>  LCID  lcid,                   // Locale</P>
<P>  WORD  wFlags,                 // Flags describing the call's context</P>
<P>  DISPPARAMS FAR*  pDispParams, // Structure containing the arguments</P>
<P>  VARIANT FAR*  pVarResult,     // Return Value of invoked call</P>
<P>  EXCEPINFO FAR*  pExcepInfo,   // Error information</P>
<P>  unsigned int FAR*  puArgErr   // Indicates which argument causes error</P>
<P>);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Examine the arguments for <B>IDispatch::Invoke</B> in more detail:</P>

<UL>
<I><LI>dispIDMember </I>is the DISPID of the method or property you want to invoke.</LI>
<I><LI>riid </I>is reserved and must be IID_NULL.</LI>
<I><LI>lcid</I> is the locale context and can be used to allow the object to interpret the call specific to a locale.</LI>
<I><LI>wFlags</I> indicates the type of member function you're invoking; are you executing a method, getting a property, or setting a property? The <I>wFlags </I>parameter can contain the following.</LI></UL>

</FONT>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_METHOD</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Executes a method</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYGET</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Gets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUT</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property</FONT></TD>
</TR>
<TR><TD WIDTH="43%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>DISPATCH_PROPERTYPUTREF</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Sets a property by a reference assignment rather than a value assignment</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>

<UL>
<I><LI>pDispParams</I> is a pointer to a <B>DISPPARAMS</B> structure; a <B>DISPPARAMS</B> is a single "package" that represents all of the parameters to pass to the method or property you're invoking. Each parameter represented by a <B>DISPPARAMS</B> structure is type <B>VARIANT.</B> (<B>VARIANT</B>s are discussed in greater detail later in this section).</LI>
<I><LI>pVarResult</I> is a pointer to another <B>VARIANT</B> type and represents the value returned from the invoked property or method.</LI>
<I><LI>pExcepInfo</I> is a pointer to an <B>EXCEPINFO</B> structure that contains exception information.</LI>
<I><LI>puArgErr</I> also contains error information. If an error occurs due to one of the parameters you passed to the invoked method or property, <I>puArgErr</I> identifies the offending parameter.</LI></UL>

<P>The simplest use of <B>IDispatch::Invoke</B> is to call a method that has no parameters and does not return a value. Now, once again consider the <B>IDispatch</B> interface in terms of your Automation client for Microsoft Word. As you might recall, the <B>TypeParagraph</B> method of the <B>Selection</B> object is one such method that had no return value and no arguments. Given the <B>IDispatch</B> pointer to the <B>Selection</B> object, you could invoke the <B>TypeParagraph</B> method with the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// pDispSel represents a pointer to the IDispatch interface of the</P>
<P>// Selection object.</P>

<P>DISIPD dispid;</P>
<P>DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};</P>
<P>HRESULT hr;</P>
<P>OLECHAR FAR* szFunction;</P>
<P>szFunction = OLESTR("TypeParagraph");</P>

<P>hr = pDispSel-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                              LOCALE_USER_DEFAULT, &amp;dispid);</P>

<P>hr = pDispSel-&gt;Invoke (dispid, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_METHOD, &amp;dispparamsNoArgs, NULL, NULL, </P>
<P>                       NULL);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Once again, this is the simplest form of <B>IDispatch::Invoke</B>;<B> </B>the method does not have any arguments and does not return a result, so all <I>pDispParams</I> needs is an empty <B>DISPPARAMS </B>structure. When you start packaging up <B>VARIANT</B>s for parameters, your code can start to become rather lengthy. </P>
<P>Before getting into sample code that uses <B>DISPPARAMS</B>, a discussion about <B>VARIANT</B>s is warranted.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Parameters and Receiving Return Values</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>VARIANT</B> is a multi-purpose data type that is used with <B>IDispatch::Invoke</B> to both pass arguments and return values because it is considered safe. <B>VARIANT</B> is a C structure that contains a member <B>vt</B><I> </I>that specifies what type of data the <B>VARIANT</B> represents. The member <I>vt</I> can contain a wide variety of type codes. You set or retrieve the actual data from the <B>VARIANT</B> using the <B>VARIANT</B>'s member that corresponds to the type code in <B>vt</B>. The table below outlines the most commonly used type codes for <I>vt </I>and the <B>VARIANT</B> member corresponding to that type code.</P>
<P> <B>NOTE</B>: The full definition of the <B>VARIANT</B> structure is in Oaidl.h.</P>
</FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="32%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the type code in <I>vt</I> is ...</B></FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Use this member in the VARIANT structure …</B></FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I2</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>short iVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_I4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>long lVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R4</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>float fltVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_R8</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>Double dblVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DATE</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>DATE date</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_CY</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>CY vtCy</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_BSTR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>BSTR bstrVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ARRAY </FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SAFEARRAY* parray</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_DISPATCH</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>IDispatch* pdispVal</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>VT_ERROR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=2><P>SCODE scode</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<P>If <I>vt </I>contained the type code VT_I4, which represents a long integer value, you would query the <B>VARIANT</B>'s <B>lVal</B><I> </I>member for the data. Likewise, if <I>vt </I>contained the type code VT_R4 to represent a 4-byte float value, you would query the <B>VARIANT</B>'s <B>fltVal</B> member for the data. Observe how this might look in code:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>// Long integer with value 9999</P>
<P>VARIANT vLongInt;</P>
<P>vLongInt.vt = VT_I4;</P>
<P>vLongInt.lVal = 9999;</P>

<P>// Float with value 5.3<BR>
VARIANT vFloat;</P>
<P>vFloat.vt = VT_R4;</P>
<P>vFloat.fltVal = 5.3;</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>You might remember <B>DISPPARAMS</B> in the discussion of <B>IDispatch::Invoke</B>. To use a <B>VARIANT</B> as an argument to an invoked method or property, the <B>VARIANT</B> argument is added to an array, which is then referenced by a <B>DISPPARAMS</B> structure. The arguments should be packaged into the array in reverse order. To use the two <B>VARIANT</B>s that were just illustrated as arguments for an invoked method, you can modify the code as shown below:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>VARIANT Args[2];</P>

<P>//Long integer with value 9999</P>
<P>Args[0].vt = VT_I4;</P>
<P>Args[0].lVal = 9999;</P>

<P>//Float with value 5.3</P>
<P>Args[1].vt = VT_R4;</P>
<P>Args[1].vt = 5.3;</P>

<P>DISPPARAMS dp;</P>
<P>dp.cArgs = 2;</P>
<P>dp.rgvarg = Args;</P>
<P>dp.cNamedArgs = 0;</P>
</FONT><I><FONT FACE="Arial" SIZE=2>
</I><B><P>NOTE:  </B>Do not forget to add the arguments to the array in reverse order. If you do not, then the invoked method fails or, at best, succeeds but gives you results that you do not expect.</P>
<P>In the previous code snippet, you could use your <B>DISPPARAMS</B> </FONT><FONT FACE="Courier New" SIZE=2>dp</FONT><FONT FACE="Arial" SIZE=2> to invoke a method that has two arguments. Suppose that the method's first parameter expects a type <B>Float</B> and the second parameter expects a <B>Long Integer</B>. You would add the <B>Long Integer</B> as the first element to the array and the <B>Float</B> as the second element of the array.</P>
<P>For the most part, retrieving and setting data with <B>VARIANT</B>s is straightforward. However, there are two data types that deserve special mention because they are very frequently used in Automation and they require a little more work: <B>BSTR</B>s and <B>SAFEARRAY</B>s.</P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Using the BSTR String Type</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To represent a string with a <B>VARIANT</B>, use the VT_BSTR type code, which corresponds to a <B>BSTR</B> type string. Automation uses <B>BSTR</B>s (or Basic STRings) so that Automation clients and servers can be created with Visual Basic. Visual Basic stores strings in the <B>BSTR</B> format: </P>
<P><IMG SRC="Image2.gif" WIDTH=522 HEIGHT=50></P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 8:   The BSTR (Basic STRing) format</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>A <B>BSTR</B> variable is a pointer to the zero-terminated character string so it is essentially the same as a wchar<I> </I>pointer. However, because of the allocated memory for the character count, you should always allocate and de-allocate the <B>BSTR</B> properly. Windows provides the <B>::SysAllocString</B> and <B>::SysFreeString</B> functions for this purpose: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Allocate a new BSTR</P>
<P>BSTR bstrMsg;</P>
<P>bstrMsg = ::SysAllocString(OLESTR("Hello"));</P>

<P>//Create a VARIANT of type VT_BSTR for the new string</P>
<P>VARIANT v;</P>
<P>v.vt = VT_BSTR;</P>
<P>v.bstrVal = bstrMsg;</P>

<P>// . . . Do something with the string data . . .</P>

<P>// Deallocate the BSTR<BR>
::SysFreeString(bstrMsg);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Using SAFEARRAYs</P>
</FONT><FONT FACE="Arial" SIZE=2><P>A <B>SAFEARRAY</B> is an array of various data types and is considered safe because the array is a protected structure that contains boundary information as well as references to the actual data.</P>
<P>A <B>SAFEARRAY</B> can have type codes similar to those of <B>VARIANT</B>s. You can create an array where all of the elements are of the same type, such as VT_I4 or VT_BSTR, or you can have an array that contains a variety of data types by creating a safe array of VT_VARIANT. To create a <B>SAFEARRAY</B>, you first set up a <B>SAFEARRAYBOUND</B> structure that contains information about the lower bounds and number of elements for each dimension of the array. Then, using this structure for the bounds and dimension information, call <B>::SafeArrayCreate</B> to create the array and specify the base type for the array. Use <B>::SafeArrayPutElement</B> to populate the array with data and then use <B>::SafeArrayGetElement</B> to retrieve the array's data. When you're done with the array, call <B>::SafeArrayDestroy</B>. The code below illustrates how to create a safe array and manipulate the array's data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>// Create a two dimensional array (2 rows x 5 columns)</P>
<P>SAFEARRAY * sa; </P>
<P>SAFEARRAYBOUND saDims[2]; </P>
<P>saDims[0].lLbound = 1;     // Lower bound of the first dimension</P>
<P>saDims[0].cElements = 2;   </P>
<P>saDims[1].lLbound = 1;     // Lower bound of the second dimension</P>
<P>saDims[1].cElements = 5;</P>

<P>sa = ::SafeArrayCreate(VT_I4, 2, saDims);</P>

<P>// Fill the array with data one element at a time</P>
<P>HRESULT hr;</P>
<P>long lIndex[2];</P>
<P>long lNum;</P>
<P>int r, c;</P>

<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      lNum = c * r;</P>
<P>      hr = ::SafeArrayPutElement(sa, lIndex, &amp;lNum);</P>
<P>   }</P>
<P>}</P>

<P>// Get the data from the array</P>
<P>for (r=1; r&lt;=2;r++)</P>
<P>{</P>
<P>   lIndex[0]=r;</P>
<P>   for (c=1;c&lt;=5;c++)</P>
<P>   {</P>
<P>      lIndex[1] = c;</P>
<P>      hr = ::SafeArrayGetElement(sa, lIndex, &amp;lNum);</P>
<P>      printf("%d\t", lNum);</P>
<P>   }</P>
<P>   printf("\n");</P>
<P>}</P>

<P>// . . . Do something with the array . . . </P>

<P>// Destroy the array when done</P>
<P>hr = ::SafeArrayDestroy(sa);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 4: Creating an Automation Client with C/C++</P>
</FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Start a new Win32 Console Application project. When prompted to select a type of console application project, choose <B>Empty Project</B>.</LI>
<LI>Add a new C++ source file to the project and copy the following code into the source file:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include &lt;ole2.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>int main(int argc, char* argv[])</P>
<P>{</P>

<P>    // *************** Declare Some Variables ********************</P>

<P>    // Variables that will be used and re-used in our calls</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    VARIANT vResult;</P>
<P>    OLECHAR FAR* szFunction;</P>
<P>    BSTR bstrTemp;</P>

<P>    // IDispatch pointers for Word's objects</P>
<P>    IDispatch* pDispDocs;      //Documents collection</P>
<P>    IDispatch* pDispSel;       //Selection object</P>
<P>    IDispatch* pDispActiveDoc; //ActiveDocument object</P>

<P>    // DISPIDs</P>
<P>    DISPID dispid_Docs;        //Documents property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_DocsAdd;     //Add method of Documents collection </P>
<P>                               //object</P>
<P>    DISPID dispid_Sel;         //Selection property of Application </P>
<P>                               //object</P>
<P>    DISPID dispid_TypeText;    //TypeText method of Selection object</P>
<P>    DISPID dispid_TypePara;    //TypeParagraph method of Selection </P>
<P>                               //object</P>
<P>    DISPID dispid_ActiveDoc;   //ActiveDocument property of </P>
<P>                               //Application object</P>
<P>    DISPID dispid_SaveAs;      //SaveAs method of the Document object</P>
<P>    DISPID dispid_Quit;        //Quit method of the Application </P>
<P>                               //object</P>

<P>    // ******************** Start Automation ***********************</P>

<P>    //Initialize the COM libraries</P>
<P>    ::CoInitialize(NULL);</P>

<P>    // Create an instance of the Word application and obtain the </P>
<P>    // pointer to the application's IDispatch interface.</P>
<P>    CLSID clsid;</P>
<P>    CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>

<P>    IUnknown* pUnk;</P>
<P>    HRESULT hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER,</P>
<P>                                     IID_IUnknown, (void**) &amp;pUnk);</P>
<P>    IDispatch* pDispApp;</P>
<P>    hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pDispApp);</P>

<P>    // Get IDispatch* for the Documents collection object</P>
<P>    szFunction = OLESTR("Documents");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Docs);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Docs, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispDocs = vResult.pdispVal;</P>

<P>    // Invoke the Add method on the Documents collection object</P>
<P>    // to create a new document in Word</P>
<P>    // Note that the Add method can take up to 3 arguments, all of </P>
<P>    // which are optional. You are not passing it any so you are </P>
<P>    // using an empty DISPPARAMS structure</P>
<P>    szFunction = OLESTR("Add");</P>
<P>    hr = pDispDocs-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_DocsAdd);</P>
<P>    hr = pDispDocs-&gt;Invoke(dispid_DocsAdd, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>

<P>    // Get IDispatch* for the Selection object</P>
<P>    szFunction = OLESTR("Selection");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_Sel);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Sel, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                           DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                           NULL, NULL);</P>
<P>    pDispSel = vResult.pdispVal;</P>

<P>&nbsp;</P>
<P>    // Get the DISPIDs of the TypeText and TypeParagraph methods of </P>
<P>    // the Selection object.  You'll use these DISPIDs multiple</P>
<P>    // times.</P>
<P>    szFunction = OLESTR("TypeText");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypeText);</P>

<P>    szFunction = OLESTR("TypeParagraph");</P>
<P>    hr = pDispSel-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_TypePara);</P>

<P>    // The TypeText method has and requires only one argument, a </P>
<P>    // string, so set up the DISPPARAMS accordingly</P>
<P>    VARIANT vArgsTypeText[1];</P>
<P>    DISPPARAMS dpTypeText;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("One"));</P>
<P>    vArgsTypeText [0].vt = VT_BSTR;</P>
<P>    vArgsTypeText [0].bstrVal = bstrTemp;</P>
<P>    dpTypeText.cArgs = 1;</P>
<P>    dpTypeText.cNamedArgs = 0;</P>
<P>    dpTypeText.rgvarg = vArgsTypeText;</P>

<P>    //Invoke the first TypeText and TypeParagraph pair</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the second TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Two"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    //Invoke the third TypeText and TypeParagraph pair</P>
<P>    bstrTemp = ::SysAllocString(OLESTR("Three"));</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypeText, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpTypeText, NULL, NULL, NULL);</P>
<P>    hr = pDispSel-&gt;Invoke (dispid_TypePara, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrTemp);</P>

<P>    // Get IDispatch* for the ActiveDocument object</P>
<P>    szFunction = OLESTR("ActiveDocument");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames (IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_ActiveDoc);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_ActiveDoc, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                           &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    pDispActiveDoc = vResult.pdispVal;</P>

<P>    //Set up the DISPPARAMS for the SaveAs method (11 arguments)</P>
<P>    VARIANT vArgsSaveAs[11];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 11;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrEmptyString;</P>
<P>    bstrEmptyString = ::SysAllocString(OLESTR(""));</P>

<P>    VARIANT vFalse;</P>
<P>    vFalse.vt = VT_BOOL;</P>
<P>    vFalse.boolVal = FALSE;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[10].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[10].bstrVal = bstrTemp;        //Filename</P>
<P>    vArgsSaveAs[9].vt = VT_I4;            </P>
<P>    vArgsSaveAs[9].lVal = 0;                   //FileFormat</P>
<P>    vArgsSaveAs[8] = vFalse;                   //LockComments</P>
<P>    vArgsSaveAs[7].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[7].bstrVal = bstrEmptyString;  //Password</P>
<P>    vArgsSaveAs[6].vt = VT_BOOL;      </P>
<P>    vArgsSaveAs[6].boolVal = TRUE;             //AddToRecentFiles</P>
<P>    vArgsSaveAs[5].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[5].bstrVal = bstrEmptyString;  //WritePassword</P>
<P>    vArgsSaveAs[4] = vFalse;                   //ReadOnlyRecommended</P>
<P>    vArgsSaveAs[3] = vFalse;                   //EmbedTrueTypeFonts</P>
<P>    vArgsSaveAs[2] = vFalse;                //SaveNativePictureFormat</P>
<P>    vArgsSaveAs[1] = vFalse;                   //SaveFormsData</P>
<P>    vArgsSaveAs[0] = vFalse;                   //SaveAsOCELetter</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, </P>
<P>                                  &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrEmptyString);</P>

<P>    //Invoke the Quit method</P>
<P>    szFunction = OLESTR("Quit");</P>
<P>    hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                 LOCALE_USER_DEFAULT, &amp;dispid_Quit);</P>
<P>    hr = pDispApp-&gt;Invoke (dispid_Quit, IID_NULL, </P>
<P>                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,</P>
<P>                           &amp;dpNoArgs, NULL, NULL, NULL);</P>

<P>    //Clean-up</P>
<P>    ::SysFreeString(bstrTemp);</P>
<P>    pDispActiveDoc-&gt;Release();</P>
<P>    pDispSel-&gt;Release();</P>
<P>    pDispDocs-&gt;Release();</P>
<P>    pDispApp-&gt;Release();</P>
<P>    pUnk-&gt;Release();</P>

<P>    ::CoUninitialize();</P>

<P>    return 0;</P>

<P>}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. When the application ends, examine the document C:\doc1.doc that the Automation code created.</LI></OL>


<P>Please note that this Automation code could be streamlined somewhat so that the code is shorter. There are other improvements, based on the Word object model, that you can implement. However, the goal of this example is to show you the one-to-one correlation between the macro you originally recorded and its equivalent C++ Automation code. How to improve upon your Automation code is dealt with in the section </FONT><A HREF="#_Improving_the_Performance"><FONT FACE="Arial" SIZE=2>"Improving the Performance of Your Automation Code"</FONT></A><FONT FACE="Arial" SIZE=2> later in this document. For now, consider some important points about this code sample that can help you when writing your own Automation code:</P>

<UL>
<LI>In the sample, you first called <B>::CoCreateInstance</B> and <B>IUnknown::QueryInterface</B> to obtain the <B>IDispatch</B> pointer to the <B>Application</B> object of Microsoft Word. Given the <B>IDispatch</B> pointer for the <B>Application</B>, you were then able to acquire <B>IDispatch</B> pointers to other interfaces by calling properties of the <B>Application</B> that return objects or object collections. Typically, this is the technique you use for navigating the object model with C++. To illustrate, you call the <B>Selection</B> property with the context DISPATCH_PROPERTYGET to obtain the <B>IDispatch</B> pointer for the <B>Selection </B>object. Given this <B>IDispatch</B> pointer, you are then able to call methods on the <B>Selection</B> object such as <B>TypeText</B> and <B>TypeParagraph</B>.</LI>
<LI>Note that you use an empty <B>DISPPARAMS</B> (</FONT><FONT FACE="Courier New" SIZE=2>dpNoArgs</FONT><FONT FACE="Arial" SIZE=2>) when you invoke a method or property where there are no arguments to pass. For example, you invoke the <B>Selection</B> property of the Application object in the context DISPATCH_PROPERTYGET with an empty <B>DISPPARAMS</B> because this property has no arguments. Note that you also invoke the <B>Add</B> method on the <B>Documents</B> object with an empty <B>DISPPARAMS</B>. If you examine the documentation for the <B>Add</B> method, you find that the <B>Add</B> method does have three optional arguments but because you were not providing any, you can use the empty <B>DISPPARAMS</B>.</LI>
<LI>You pass the arguments for the <B>SaveAs</B> method of the <B>Document</B> object in an order that is reversed from the documentation. In the documentation for the <B>SaveAs </B>method, the <I>FileName</I><B> </B>argument is the first of eleven arguments, but when you set up the <B>VARIANT</B> array for the <B>DISPPARAMS</B> structure, you specify the <I>Filename</I> as the eleventh element (index 10) of the array. When you are using multiple arguments with an invoked function, always pass them in reverse order. </LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Passing Optional Arguments to Methods</P><DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>One thing you can do to streamline the code in the previous exercise is to pass only those arguments that you really need for invoked functions and omit some of the optional arguments, especially for the <B>SaveAs</B> method, which has eleven arguments.</P>
<P>In the exploration of the object model documentation, you’ll recall that some methods of Automation objects have arguments that are optional. When you need to omit an optional argument for a method and you cannot leave it blank, you can pass a <B>VARIANT</B> of type VT_ERROR with its <I>scode</I> member set to DISP_E_PARAMNOTFOUND.</P>
<P>The <B>SaveAs</B> method of Word's <B>Document</B> object is one such method; only the first argument, the <I>Filename</I> argument, is required and all other arguments are optional.  Revisit your Automation code from the previous exercise and rewrite the call to invoke the <B>SaveAs</B> method so that you pass only the arguments that you need to provide; any arguments that you omit take on the default values as specified in the documentation for the <B>SaveAs</B> method. Suppose that you wanted to provide values for only two arguments: the <I>Filename</I> argument (the first argument) and the <I>Password</I> argument (the fourth argument). In Visual Basic for Applications syntax, this would look like:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>ActiveDocument.SaveAs "c:\doc1.doc", , ,"pwd"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This call to <B>SaveAs</B> specifies only the first and fourth of the eleven arguments and omits all the others. With C++, you can accomplish the same behavior by creating a four element <B>VARIANT</B> array where element 3 is type VT_BSTR for the filename, elements 2 and 1 are type VT_ERROR with an <I>scode</I> of DISP_E_PARAMNOTFOUND for "omitted," and element 0 is type VT_BSTR for the password (remember that you set up the <B>VARIANT</B> array with the arguments in reverse order):</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    //Set up the DISPPARAMS for the SaveAs method, using only 4 of its 11 </P>
<P>    //possible arguments</P>
<P>    VARIANT vArgsSaveAs[4];</P>
<P>    DISPPARAMS dpSaveAs;</P>
<P>    dpSaveAs.cArgs = 4;</P>
<P>    dpSaveAs.cNamedArgs = 0;</P>
<P>    dpSaveAs.rgvarg = vArgsSaveAs;</P>

<P>    BSTR bstrPassword;</P>
<P>    bstrPassword = ::SysAllocString(OLESTR("pwd"));</P>

<P>    VARIANT vOpt;</P>
<P>    vOpt.vt = VT_ERROR;</P>
<P>    vOpt.scode = DISP_E_PARAMNOTFOUND;</P>

<P>    bstrTemp = ::SysAllocString(OLESTR("c:\\doc1.doc"));</P>
<P>    vArgsSaveAs[3].vt = VT_BSTR;         </P>
<P>    vArgsSaveAs[3].bstrVal = bstrTemp;       //Filename</P>
<P>    vArgsSaveAs[2] = vOpt;                   //FileFormat - omitted</P>
<P>    vArgsSaveAs[1] = vOpt;                   //LockComments - omitted</P>
<P>    vArgsSaveAs[0].vt = VT_BSTR;</P>
<P>    vArgsSaveAs[0].bstrVal = bstrPassword;   //Password</P>

<P>&nbsp;</P>
<P>    //Invoke the SaveAs method</P>
<P>    szFunction = OLESTR("SaveAs");</P>
<P>    hr = pDispActiveDoc-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                                  LOCALE_USER_DEFAULT, &amp;dispid_SaveAs);</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, NULL, NULL);</P>
<P>    ::SysFreeString(bstrPassword);</P>
</FONT><FONT FACE="Arial" SIZE=2><P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Special Case for Property Put Functions</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For methods and property get functions, all arguments can be accessed as positional without the need for named arguments. On the other hand, property put functions require named arguments because they have a named argument that is the new value for the property you are setting. The DispID of this argument is DISPID_PROPERTYPUT.</P>
<P>To illustrate, revisit your sample C++ Automation Client in Exercise 4. Suppose that you want to make the Word application visible instead of quitting it after the document is saved. To do this, you can set the Application's object <B>Visible</B> property to <B>True</B> by invoking the <B>Visible</B> property in the DISPATCH_PROPERTYPUT context. In your sample C++ Automation client, you can replace the invocation of the <B>Quit</B> method with the following code to make Word visible:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>//Make Word Visible</P>
<P>DISPID dispid_Visible;</P>
<P>szFunction = OLESTR("Visible");</P>
<P>hr = pDispApp-&gt;GetIDsOfNames(IID_NULL, &amp;szFunction, 1, </P>
<P>                             LOCALE_USER_DEFAULT, &amp;dispid_Visible);</P>
<P>VARIANT pArgs2[1];</P>
<P>DISPPARAMS dpVisible;</P>
<P>pArgs2[0].vt= VT_BOOL;</P>
<P>pArgs2[0].boolVal = TRUE;</P>
<P>dpVisible.cArgs = 1;</P>
<P>dpVisible.cNamedArgs = 1;</P>
<P>dpVisible.rgvarg = pArgs2;</P>
<P>DISPID dispidNamed = DISPID_PROPERTYPUT;</P>
<P>dpVisible.rgdispidNamedArgs = &amp;dispidNamed;</P>

<P>hr = pDispApp-&gt;Invoke (dispid_Visible, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                       DISPATCH_PROPERTYPUT, &amp;dpVisible, NULL, NULL, </P>
<P>                       NULL);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>Note that for the <B>DISPPARAMS</B> structure, you set the <B>cNamedArgs</B> member to 1 and the <B>rgdispidNamedArgs</B> member to a DispID of DISPID_PROPERTYPUT. If you attempt to call the property put<B> </B>function (the <B>Visible</B> property) without specifying the named argument, <B>IDispatch::Invoke</B> would fail with an HRESULT 0x80020004 "Parameter not found." </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Error Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With COM, there are two general types of errors that can occur:</P>

<UL>
<LI>An error can occur with a call because COM could not make it work.</LI></UL>
<DIR>

<P>-or-</P></DIR>


<UL>
<LI>An error can occur on the server's end in a function call. </LI></UL>

<P>These errors are described in <B>HRESULT</B> and <B>EXCEPINFO</B> structures, respectively.</P>
<P>An <B>HRESULT</B> is a 32-bit return value that represents success or failure. When a call fails, the <B>HRESULT</B> contains an error value that provides you with a general idea of the cause. For example, if you try to pass a parameter to an invoked function and the parameter cannot be coerced to the correct type, you receive an <B>HRESULT</B> with the value of DISP_E_TYPEMISMATCH. Or, if you call <B>IDispatch::GetIDsOfNames</B> to obtain the DISPID for a function that an object does not support, you get an <B>HRESULT</B> of DISP_E_MEMBERNOTFOUND. You can call <B>::FormatMessage</B> to retrieve a textual description for the error. </P>
<B><P>NOTE: </B>For a complete list of <B>HRESULT</B> values and their descriptions, refer to the documentation for <B>IDispatch::Invoke</B> on MSDN.</P>
<P>If <B>IDispatch::Invoke</B> returns an <B>HRESULT</B> of DISP_E_EXCEPTION, this indicates that an error occurred in the actual execution of the invoked function on the server's end. You can examine the <B>EXCEPINFO</B> structure you passed to <B>IDispatch::Invoke</B> for more details on the error. The <B>EXCEPINFO</B> structure contains a numeric error code, a textual error description, and information about how you can find the Help topic for the error. </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 5: Implementing an Error Handler for Your Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you implement an error handling routine for the Automation client you created in Exercise 4 and intentionally break some of the code so that you can see what types of errors can occur:</P>
<OL>

<LI>Add the following error routine to the CPP file you created for the Automation client in the previous exercise:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void ErrHandler(HRESULT hr, EXCEPINFO excep)</P>
<P>{</P>
<P>    if(hr==DISP_E_EXCEPTION)</P>
<P>    {</P>
<P>        char errDesc[512];</P>
<P>        char errMsg[512];</P>
<P>        wcstombs(errDesc, excep.bstrDescription, 512);</P>
<P>        sprintf(errMsg, "Run-time error %d:\n\n %s", </P>
<P>                excep.scode &amp; 0x0000FFFF,  //Lower 16-bits of SCODE</P>
<P>                errDesc);                  //Text error description</P>
<P>        ::MessageBox(NULL, errMsg, "Server Error", MB_SETFOREGROUND | </P>
<P>                     MB_OK);</P>
<P>    }</P>
<P>    else</P>
<P>    {</P>
<P>        LPVOID lpMsgBuf;</P>
<P>        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                        FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                        FORMAT_MESSAGE_IGNORE_INSERTS, NULL, hr,</P>
<P>                        MAKELANGID(LANG_NEUTRAL, </P>
<P>                        SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsgBuf,</P>
<P>                        0, NULL);</P>
<P>        ::MessageBox(NULL, (LPCTSTR)lpMsgBuf, "COM Error", </P>
<P>                     MB_OK | MB_SETFOREGROUND);</P>
<P>        ::LocalFree( lpMsgBuf );</P>
<P>    }</P>

<P>}</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Modify the call to invoke the <B>SaveAs</B> method of the <B>Document</B> object to implement error handling by changing this line:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                             LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                             &amp;dpSaveAs, NULL, NULL, NULL); </P>
</FONT><FONT FACE="Arial" SIZE=2><P>to this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    EXCEPINFO excep;</P>
<P>    hr = pDispActiveDoc-&gt;Invoke(dispid_SaveAs, IID_NULL, </P>
<P>                                LOCALE_USER_DEFAULT, DISPATCH_METHOD, </P>
<P>                                &amp;dpSaveAs, NULL, &amp;excep, NULL); </P>
<P>    if (FAILED(hr))</P>
<P>    {</P>
<P>        ErrHandler(hr, excep);</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Compile and run the application. Everything should work as expected without error and the error handling routine should not be called.</LI>
<LI>Break the code to see the error handler in action. Change the <I>Filename</I> argument for the <B>SaveAs</B> method to an incorrect type, VT_I4:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>pArgsSaveAs[10].vt = VT_I4;</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This causes a COM failure because the call to <B>IDispatch::Invoke</B> fails when trying to coerce the long integer data type to a string, which is what <B>SaveAs</B> expects for the <I>Filename</I> argument. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_TYPEMISMATCH as you expected and the error handler displays the error:</P>

<LI>Change the type code for the <I>Filename</I> argument back to VT_BSTR so that the type code is correct but change the string for the <I>Filename</I> argument so that the path is not valid:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>bstrTemp = ::SysAllocString(OLESTR("c:\\badpath\\doc1.doc")); </P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this scenario, <B>IDispatch::Invoke</B> can call the <B>SaveAs</B> method with the proper argument types but the <B>SaveAs</B> function itself fails because of the invalid path. Build and run the application. <B>IDispatch::Invoke</B> returns DISP_E_EXCEPTION to indicate that the server reported an error with the function execution. The error handler routine examines the <B>EXCEPINFO</B> structure passed to<B> IDispatch::Invoke</B> and displays a descriptive error message:</P>

<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate a Running Instance of an Office Application</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Automation servers that are running register their objects in what is called the Running Object Table (or ROT). To attach to a running instance of an Automation server, you can provide the object's CLSID to <B>::GetActiveObject()</B> and obtain a pointer to the object's <B>IUnknown</B> interface. Given the pointer to <B>IUnknown</B>, you can call <B>IUnknown::QueryInterface</B> to get to the object's <B>IDispatch</B> interface. The following sample illustrates this behavior:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
// Get a pointer to IUnknown for the running instance</P>
<P>HRESULT hr;</P>
<P>IUnknown *pUnk;</P>
<P>CLSID clsid;</P>
<P>CLSIDFromProgID(L"Word.Application", &amp;clsid);  </P>
<P>hr = GetActiveObject(clsid, NULL, (IUnknown**)&amp;pUnk);</P>

<P>// Get IDispatch </P>
<P>IDispatch *pDisp;</P>
<P>hr = pUnk-&gt;QueryInterface(IID_IDispatch, (void **)&amp;pDisp);<BR>
<BR>
// . . . Use the IDispatch pointer for automation . . .</P>

<P>// Release interface pointers for proper clean-up</P>
<P>pDisp-&gt;Release();</P>
<P>pUnk-&gt;Release();</P>

</FONT><FONT FACE="Arial" SIZE=2><P>There are special considerations you should note when using <B>::GetActiveObject()</B>. If there are multiple running instances of the Office application you want to control, <B>::GetActiveObject() </B>returns the pointer to the <B>IUnknown</B> interface of the instance that was first running. There is no foolproof solution for attaching to a specific instance of an application.</P>
<P>An Office application does not register its <B>Application</B> object if another instance is already in the ROT because the moniker for it is always the same. However, because the Office applications also register their documents in the ROT, you can attach to instances other than the one that was first running by:</P>
<OL>

<LI>Iterating the ROT to locate a specific open document.</LI>
<LI>Attaching to the open document.</LI>
<LI>Navigating the object model for the <B>Application </B>object. </LI></OL>

<P>Note that this solution is still not foolproof because there is no guarantee that a document is not open in two separate instances of an application. If you are interested in a code example that illustrates how to iterate the ROT to locate an open document by name, see the following article in the Microsoft Knowledge Base: </P>
<P> Q190985 HOWTO: Get IDispatch of an Excel or Word Document From an OCX<BR>
 </FONT><A HREF="http://support.microsoft.com/support/kb/articles/q190/9/85.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q190/9/85.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Creating an Automation client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Now that you have created your Automation client with straight C++, you can see how MFC simplifies this task for you and cuts down the amount of code you write.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>The COleDispatchDriver Class</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides a <B>COleDispatchDriver</B> class for handling <B>IDispatch</B> interfaces of Automation objects. You can use the Visual C++ ClassWizard to automatically generate <I>wrapper classes</I> from a Microsoft Office type library.  All the classes in the type library that implement <B>IDispatch</B> are wrapped into a new class that is derived from <B>COleDispatchDriver</B>. The ClassWizard also creates member functions that map to all the properties and methods that a class exposes. </P>
<P>These wrapper classes provide several benefits to the MFC programmer:</P>

<UL>
<LI>ClassWizard sets up the call to invoke the function and provides the DISPID, context, parameters, and return value. Thus, you rarely need to make COM calls directly to retrieve function DISPIDs or to invoke functions. </LI>
<B><LI>COleDispatchDriver</B> handles reference counts. </LI>
<LI>ClassWizard generates a member function in such a way that you can pass the function arguments without building a <B>DISPPARAMS</B> structure.</LI>
<LI>The <B>COleVariant</B> class encapsulates the <B>VARIANT</B> data type. With MFC, you can use <B>COleVariant</B>s for your parameters and return values for the wrapped functions.</LI></UL>

<B><P>COleDispatchDriver</B> supports several functions for communicating with Automation servers. The following list describes the ones you are most likely to use.</P>
<P> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::CreateDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Starts a new instance of the server and attaches the <B>COleDispatchDriver</B> object to the server's <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::AttachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Attaches an <B>IDispatch</B> connection to the <B>COleDispatchDriver</B> object </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::DetachDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Detaches a <B>COleDispatchDriver</B> object from an <B>IDispatch</B> interface but does not release it </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::ReleaseDispatch()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Releases an <B>IDispatch</B> interface </FONT></TD>
</TR>
<TR><TD WIDTH="49%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>COleDispatchDriver::InvokeHelper()</B></FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Invokes properties and methods</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<B><P>COleDispatchDriver</B> also has a data member <B>m_lpDispatch</B>, which, as its name implies, is the pointer to the <B>IDispatch</B> interface and is type <B>LPDISPATCH</B>. This data member is often useful when you need to package a <B>VARIANT</B> of type VT_DISPATCH as an argument to an invoked function.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Exercise 6: Creating an Automation Client with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you will create a MFC Automation client with the same functionality as the your C/C++ Automation client. As you progress through the exercise, you might notice that the code has a much clearer one-to-one correlation with the recorded Word macro. This is the attraction of writing Automation code with MFC and the wrapper classes that ClassWizard generates for you.</P>
<OL>

<LI>In Visual Studio, start a new dialog-based MFC AppWizard(EXE) project named Exercise6.</LI>
<LI>On the <B>View</B> menu, click <B>ClassWizard,</B>  and go to the <B>Automation</B> tab. Click <B>Add Class</B> and choose <B>From A Type Library</B>. Browse to the Microsoft Word 97 type library Msword8.olb (or Msword9.olb if you are using Word 2000) and click <B>OK</B>. Select all of the classes the ClassWizard presents and click <B>OK</B>.</LI>
<P> </P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 9:   Use the ClassWizard to create wrapper functions from a type library.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P><BR>
This process generates two new files in your project: Msword8.cpp and Msword8.h. These files make up the wrapper classes for all the classes and class member functions that the Word type library exposes. Next, examine one of the properties that you will use in your code: the <B>Documents</B> property. As you might recall from your examination of the Object model documentation, <B>Documents</B> is a property of the <B>Application</B> object and returns a <B>Documents</B> collection object that represents all the open documents.</P>
<LI>On the <B>Project Workspace</B> window, click the <B>ClassView </B>tab. Expand "Exercise6 Classes" to display all the classes that the ClassWizard generated from the Word type library. Double-click the <B>_Application</B> class to display its definition in the Text Editor window. Note that the <B>_Application</B> class is derived from <B>COleDispatchDriver:</LI>
</B></FONT><FONT FACE="Courier New" SIZE=1><P>// _Application wrapper class<BR>
<BR>
class _Application : public COleDispatchDriver<BR>
{<BR>
<BR>
. . .<BR>
<BR>
}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Expand the <B>_Application </B>class on the <B>ClassView </B>tab to display all of its member functions. Double-click <B>GetDocuments() </B>to display its definition in the Text Editor window:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()</P>
<P>{</P>
<P>&#9;LPDISPATCH result;</P>
<P>&#9;InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&amp;result, </P>
<P>                NULL);</P>
<P>&#9;return result;</P>
<P>}<BR>
<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The definition of</FONT><FONT FACE="Arial" SIZE=1> </FONT><B><FONT FACE="Arial" SIZE=2>Application::GetDocuments </B>tells you that it makes a call to <B>COleDispatchDriver::InvokeHelper</B> to invoke the <B>Documents</B> property (DISPATCH_PROPERTYGET) using the DISPID 0x6. <B>_Application::GetDocuments()</B> returns an <B>IDispatch</B> pointer to the <B>Documents</B> class. </P>
<B><P>NOTE</B>: In Visual Basic for Applications, this function is called the <B>Documents </B>property, but the ClassWizard names this function <B>GetDocuments</B>. The ClassWizard names a function based on the context in which the function is invoked.</P>
</FONT>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=542>
<TR><TD WIDTH="56%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>If the function is a …</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ClassWizard generates a member function named…</B></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P> Property that returns a value (DISPATCH_PROPERTYGET)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Get</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property that sets a value (DISPATCH_PROPERTYPUT)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Set</B><I>Function</I></FONT></TD>
</TR>
<TR><TD WIDTH="56%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Method (DISPATCH_METHOD)</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<I><FONT FACE="Arial" SIZE=2><P>Function</I></FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2><P><BR>
With <B>ClassView</B>, examine the equivalent member functions for all the objects, properties, and methods that the recorded Word macro used. Compare the member function to its Visual Basic for Applications equivalent in the Object Model documentation and you can see a definite correlation. The documentation provides you with a description of the function's purpose, a description of each argument, and the function's return value.<BR>
</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=566>
<TR><TD WIDTH="39%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>In Visual Basic for Applications, the property or method is called…</B></FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>And its equivalent ClassWizard-generated member function is…</B></FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Documents</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetDocuments()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Add</B> Method of the <B>Documents</B> Collection Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH Documents::Add(VARIANT* Template, </P>
<P>   VARIANT* NewTemplate)<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>Selection</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH__Application::GetSelection()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeText</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeText(LPCTSTR Text)<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>TypeParagraph</B> Method of the <B>Selection</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void Selection::TypeParagraph()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>ActiveDocument</B> Property of the <B>Application</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>LPDISPATCH _Application::GetActiveDocument()<BR>
<BR>
<BR>
</FONT></TD>
</TR>
<TR><TD WIDTH="39%" VALIGN="TOP"><DIR>
<DIR>

<B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> Method of the <B>Document</B> Object</DIR>
</DIR>
</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Courier New" SIZE=1><P>void _Document::SaveAs(VARIANT* FileName, </P>
<P>   VARIANT* FileFormat, <BR>
   VARIANT* LockComments, </P>
<P>   VARIANT* Password, <BR>
   VARIANT* AddToRecentFiles, </P>
<P>   VARIANT* WritePassword, </P>
<P>   VARIANT* ReadOnlyRecommended, </P>
<P>   VARIANT* EmbedTrueTypeFonts, </P>
<P>   VARIANT* SaveNativePictureFormat, </P>
<P>   VARIANT* SaveFormsData, <BR>
   VARIANT* SaveAsAOCELetter)</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following code to <B>CExercise6App::InitInstance</B> in Exercise6.cpp so that COM services are enabled when your application is initialized:</LI>
<P><BR>
</FONT><FONT FACE="Courier New" SIZE=1>if(!AfxOleInit()) <BR>
{<BR>
   AfxMessageBox("Could not initialize COM services");<BR>
   return FALSE;<BR>
}<BR>
</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Next, select the dialog resource IDD_EXERCISE6_DIALOG. Add a button to the dialog box and name the button IDC_RUN. Add the following code to the button handler:<BR>
</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>
<P>    </P>
<P>    //Create a new document</P>
<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);  <BR>
    //Note for Word 2000: The Add method has 4 arguments in Word 2000.  If </P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Add text to the document</P>
<P>    Selection oSel;</P>
<P>    oSel = oWordApp.GetSelection();</P>
<P>    oSel.TypeText("one");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("two");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("three");</P>

<P>    //Save the document</P>
<P>    _Document oActiveDoc; </P>
<P>    oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>    oActiveDoc.SaveAs(COleVariant("c:\\doc1.doc"), </P>
<P>                    COleVariant((short)0),</P>
<P>                    vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                    vFalse, vFalse, vFalse, vFalse, vFalse);</P>

<P>    //Quit the application</P>
<P>    oWordApp.Quit(vOpt, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2><P><BR>
<B>NOTE</B>:<B> </B>The <B>Documents::Add</B> method in the type library for Microsoft Word 2000 has four arguments, whereas Microsoft Word 97 only has two. If you added wrappers using the Word 2000 type library (Msword9.olb) in step 2, modify the <B>Add</B> method in the code so that it has four arguments, for example:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the directive to include Msword8.h in Exercise6Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "msword8.h"   //or "msword9.h" for Word 2000</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>NOTE</B>: Add this include directive <U>after</U> the include directive for "stdafx.h." Otherwise, you might receive compile errors.<BR>
</P>
<LI>Build and run the application. Click the button to run the Automation code. Confirm that your Automation client created C:\Doc1.doc and that the document contains the text that you expect.</LI></OL>

<P>There are some important points to observe about the Automation code in this exercise:</P>

<UL>
<LI>When you call a member function for a wrapper class, you must provide all arguments to the function. You can omit optional arguments by passing a <B>COleVariant</B> with the type code VT_ERROR and the <I>scode</I> DISP_E_PARAMNOTFOUND.</LI>
<LI>When calling member functions that return a pointer to an <B>IDispatch</B> interface (type <B>LPDISPATCH</B>), you can directly assign the return value to a <B>COleDispatchDriver</B> derived class to attach it to the returned <B>IDispatch </B>pointer:</LI></UL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs = oWordApp.GetDocuments();</P>
<P>    oDoc = oDocs.Add(vOpt, vOpt);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>This is essentially the same as:</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<P>    Documents oDocs;</P>
<P>    _Document oDoc;</P>
<P>    oDocs.AttachDispatch(oWordApp.GetDocuments());</P>
<P>    oDoc.AttachDispatch(oDocs.Add(vOpt, vOpt));</P>
</FONT><FONT FACE="Arial" SIZE=2></DIR>


<UL>
<LI>You did not directly call <B>COleDispatchDriver::ReleaseDispatch() </B>to release the objects and decrement reference counts. <B>COleDispatchDriver</B> has a data member, <B>m_bAutoRelease,</B> which is set to <B>True</B> when it is constructed. When <B>m_bAutoRelease</B> is <B>True</B>, the object is released when it is destroyed. Because all of the <B>COleDispatchDriver</B>-derived classes in your client have procedure-level scope, the objects are all released automatically when the procedure ends.</LI>
<LI>In this particular example, you did not use the <B>Document</B> object </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> that was returned from <B>Documents::Add(), </B>but you assigned the return value anyway. <B>Documents::Add()</B> effectively increases the reference count for the <B>Document</B> object when it requests a pointer to its <B>IDispatch</B> interface. This reference count is properly decremented when the procedure ends and the <B>Document</B> object variable </FONT><FONT FACE="Courier New" SIZE=2>Doc</FONT><FONT FACE="Arial" SIZE=2> loses scope. If you had ignored the returned <B>LPDISPATCH</B>, you might have encountered a problem with the object's reference count and the server might have remained in memory even after your Automation client ended. You should be aware of return values, especially those of type <B>LPDISPATCH</B>.</LI></UL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Exception Handling</P>
</FONT><FONT FACE="Arial" SIZE=2><P>MFC provides two classes for handling exceptions with your Automation code:  <B>COleException</B> and <B>COleDispatchException</B>.  Both of these classes are derived from the <B>CException</B> base class and can be used with <B>try </B>blocks<B> </B>and<B> catch</B> handlers.</P>
<P>You use <B>COleException</B> to handle general failures with COM calls and <B>COleDispatchException</B> to handle errors that occur on the server's end.  </P>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 7: Implement Exception Handling in Your Automation Client</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This exercise implements exception handling in the MFC Automation client you created in the previous exercise, and then breaks the Automation code so that you can see the exception handler in action.</P>
<OL>

<LI>Modify <B>CExercise6Dlg::OnRun</B> to implement exception handling:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    //Commonly used variants.</P>
<P>    COleVariant vTrue((short)TRUE),</P>
<P>                vFalse((short)FALSE),</P>
<P>                vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    //Start a new instance of Microsoft Word</P>
<P>    _Application oWordApp;</P>
<P>    if (!oWordApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("CreateDispatch failed.", </P>
<P>                      MB_OK | MB_SETFOREGROUND);</P>
<P>        return;</P>
<P>    }</P>

<P>    try</P>
<P>    {</P>

<P>      //Create a new document</P>
<P>      Documents oDocs;</P>
<P>      _Document oDoc;</P>
<P>      oDocs = oWordApp.GetDocuments();</P>
<P>      oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>      //Note for Word 2000: The Add method has 4 arguments in Word 2000.  </P>
<P>      //If you wrapped the classes from the Word type library </P>
<P>      //(msword9.olb),modify the Add method to provide 4 optional </P>
<P>      //arguments:</P>
<P>      //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>      //Add text to the document</P>
<P>      Selection oSel;</P>
<P>      oSel = oWordApp.GetSelection();</P>
<P>      oSel.TypeText("one");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("two");</P>
<P>      oSel.TypeParagraph();</P>
<P>      oSel.TypeText("three");</P>

<P>      //Save the document</P>
<P>      _Document oActiveDoc; </P>
<P>      oActiveDoc = oWordApp.GetActiveDocument();</P>
<P>      oActiveDoc.SaveAs(COleVariant("c:\\ doc1.doc"), </P>
<P>                        COleVariant((short)0),</P>
<P>                        vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                        vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<P>   }</P>
<P>    </P>
<P>   catch(COleException *e)</P>
<P>   {</P>
<P>      LPVOID lpMsg;</P>
<P>      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | </P>
<P>                     FORMAT_MESSAGE_FROM_SYSTEM | </P>
<P>                     FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e-&gt;m_sc,</P>
<P>                     MAKELANGID(LANG_NEUTRAL, </P>
<P>                     SUBLANG_DEFAULT),(LPTSTR) &amp;lpMsg,</P>
<P>                     0, NULL);</P>
<P>      ::MessageBox(NULL, (LPCTSTR)lpMsg, "COM Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);</P>
<P>      ::LocalFree( lpMsg );</P>
<P>   }</P>

<P>   catch(COleDispatchException *e)</P>
<P>   {</P>
<P>      char msg[512];</P>
<P>      sprintf(msg, "Run-time error '%d':\n\n%s", </P>
<P>           e-&gt;m_scError &amp; 0x0000FFFF, e-&gt;m_strDescription);</P>
<P>      ::MessageBox(NULL, msg, "Server Error", </P>
<P>                  MB_OK | MB_SETFOREGROUND);      </P>
<P>   }</P>

<P>&nbsp;</P>
<P>   //Quit the application</P>
<P>   oWordApp.Quit(vFalse, vOpt, vOpt);</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Build and run the application. Everything should work as expected and no exceptions should occur.</LI>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <B>COleVariant</B> of type VT_I4 for the first argument, the<B> </B><I>Filename</I> argument:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   oActiveDoc.SaveAs(COleVariant((long)5)), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>

</FONT><B><FONT FACE="Arial" SIZE=2><P>SaveAs</B> expects a string for the <I>Filename</I> argument so you expect this to generate an error. Build and run the application. When you click the button, the code generates a <B>COleException</B> when invoking the <B>SaveAs</B> method due to a type mismatch for the <I>Filename</I> argument. The exception handler displays a message box:</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<LI>Modify the <B>SaveAs</B> method so that you are passing it a <I>Filename</I> with an invalid path:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><P><BR>
   oActiveDoc.SaveAs(COleVariant("c:\\badpath\\doc1.doc"), </P>
<P>                     COleVariant((short)0),</P>
<P>                     vFalse, COleVariant(""), vTrue, COleVariant(""),</P>
<P>                     vFalse, vFalse, vFalse, vFalse, vFalse);</P>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>COM is able to invoke the <B>SaveAs</B> method because, as far as COM is concerned, it has the correct DISPID, the correct argument types, and so forth. However, the <B>SaveAs</B> method itself fails because of the invalid path. Build and run the application. When the <B>SaveAs</B> method is invoked, the method fails and generates a <B>COleDispatchException</B> and the exception handler kicks in to display the error:</P>

<P>Note that the server's <B>Quit </B>method is called after the <B>catch</B> handlers. Using this layout, when an exception occurs, the <B>Quit</B> method is still called. If the <B>Quit</B> method were in the <B>try</B> block instead, then it might not get invoked if an exception occurs and you could risk leaving the server in memory when the procedure ends.</P>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Improving the Performance of Your Automation Code</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Your best tools for writing robust Automation code are: </P>
<P>1. A good understanding of the Automation server's object model. </P>
<P>-and- </P>
<P>2. The documentation for the objects, methods, and properties you intend to use. </P>
<P>The macro recorder in Office applications is an excellent tool for understanding how to accomplish a task with the application's object model and, in some situations, it gives you a great foundation for starting your Automation client. This was illustrated in the previous exercises by translating a recorded Word macro, line-by-line, to create perfectly functional Automation clients. </P>
<P>The macro recorder records actions in the user interface; it records every click and every keystroke you make. Thus, by its very nature, the macro recorder can often generate rather lengthy code that is not as efficient as it could be. To take a recorded macro and improve it, you need an understanding of the application's object model. Obviously this paper cannot cover every object in all the Office object models, but it can provide an overview of the more common techniques you can use to improve your Automation code. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #1 – Minimize "Selecting" or "Activating" Objects When Possible</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Remember that the macro recorder records every action you take in the user interface. In the user interface, when you change an object's property, the macro recorder records both the action of selecting the object and the action of setting the object's property. To shorten this process, you could omit the selection action altogether, when possible, and set the property directly.</P>
<P>To illustrate, if you were to record a macro in Microsoft Excel while performing the following actions:</P>
<OL>

<LI>Start a new workbook.</LI>
<LI>Select "Sheet2."</LI>
<LI>Type "Hello World" in cell B2, and press the ENTER key.  </LI></OL>

<P>your recorded macro should look like this: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Workbooks.Add</P>
<P> Sheets("Sheet2").Select</P>
<P> Range("B2").Select</P>
<P> ActiveCell.FormulaR1C1 = "Hello World"</P>
<P> Range("B3").Select</P>

</FONT><FONT FACE="Arial" SIZE=2><P>By examining the object model documentation for Excel, you can determine that a <B>Range</B> is a child of a <B>Worksheet</B> and a <B>Worksheet</B> is a child of a <B>Workbook</B>. Given this information, you can streamline the code to omit both the selection of the sheet and the selection of the cell:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> Dim Book as Workbook</P>
<P> Set Book = Workbooks.Add</P>
<P> Book.Sheets("Sheet2").Range("B2").Value = "Hello World"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This is a small example and might not look like much, but if you are automating Excel to perform this operation 100 times or more, then this change can be significant.</P>
<P>Now consider a macro you record in Word to start a new document, insert a 2 x 2 table, and add data to all four cells in the table. Your recorded macro might look like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Documents.Add DocumentType:=wdNewBlankDocument</P>
<P>ActiveDocument.Tables.Add Range:=Selection.Range, _</P>
<P>         NumRows:=2, NumColumns:=2</P>
<P>Selection.TypeText Text:="a"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="b"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="c"</P>
<P>Selection.MoveRight Unit:=wdCell</P>
<P>Selection.TypeText Text:="d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>With an understanding of how the Word object model is constructed, you can improve the code by omitting the need to select each cell in the table to fill it with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim Doc As Document</P>
<P>Set Doc = Documents.Add</P>

<P>Dim Tbl As Table</P>
<P>Set Tbl = Doc.Tables.Add(Range:=Selection.Range, _</P>
<P>    NumRows:=2, NumColumns:=2)</P>
<P>    </P>
<P>Tbl.Cell(1, 1).Range.Text = "a"</P>
<P>Tbl.Cell(1, 2).Range.Text = "b"</P>
<P>Tbl.Cell(2, 1).Range.Text = "c"</P>
<P>Tbl.Cell(2, 2).Range.Text = "d"</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Using this solution, you are able to fill a cell in a Word table by referencing the cell by its row and column number rather than having to use the "move" methods to move from one cell to another.</P>
<P>There are reasons other than just performance for you to avoid selecting or activating objects in your Automation code. When an Office application is automated, it is often hidden and therefore does not have a window associated with it. Some methods or properties that rely on a window might not behave as expected when the application is not visible. So, to be safe, it is best that you avoid "select" and "activate" methods with Automation whenever possible.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #2 – Minimize the Server's Screen Repaints</P>
</FONT><FONT FACE="Arial" SIZE=2><P>When an Automation server is visible, changes you make to the server's content can force the server to refresh. If you have a relatively large task to accomplish with an Automation server, complete the task before making the application visible. If your situation requires that the server be visible while you automate it, you might benefit from telling the server not to refresh until the task is complete. The <B>Application</B> objects for Excel and Word have a <B>ScreenUpdating</B> property that you can set to <B>False</B> to prevent screen updates while your Automation code executes. Microsoft Access has a similar property: the <B>Echo</B> property of the <B>Application</B> object.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #3 – Use Arrays</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Some methods and properties can take either a single item or an array of items for an argument. Whether or not an array can be passed for an argument is documented in the Help for the property or method in question. Use the Office Visual Basic for Applications documentation to your advantage.</P>
<P>Consider the following Excel macro code that populates four cells with data:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>With Worksheets(1)</P>
<P>    .Range("a1").Value = "Last Name"</P>
<P>    .Range("b1").Value = "First Name"</P>
<P>    .Range("c1").Value = "MI"</P>
<P>    .Range("d1").Value = "Title"</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>The <B>Value</B> property of a <B>Range</B> object can accept either a single value or an array of values. So, you can rewrite the code to use an array: </P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Worksheets(1).Range("a1:d1").Value = _</P>
<P>               Array("Last Name", "First Name", "MI", "Title")</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this example, you are using a single dimensional array but the <B>Value</B> property of the <B>Range</B> object can be set to a two-dimensional array as well. </P>
<B><P>NOTE</B>: For C/C++ and MFC developers: You can pass a <B>SAFEARRAY</B> or <B>COleSafeArray</B> for the invoked <B>Value</B> property of a <B>Range</B> object.</P>
<P>For Visual Basic and MFC codes samples that illustrate how you can use arrays to transfer data to an Excel worksheet, see the section </FONT><A HREF="#_Automate_Excel_to"><FONT FACE="Arial" SIZE=2>"Automate Excel to Create and Format a New Workbook."</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>Tip #4 – Use the Features of the Automation Server to Your Benefit</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office Automation servers provide many timesaving methods and properties that can simplify your Automation code when you are using repetitive tasks.</P>
<P>Again, consider Excel as an Automation server for a moment. Suppose you wanted to format all of the "used" cells in column "A," starting at row 1, with a bold font but you do not know exactly how many used cells there are in that column. You might try something like this:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSheet is a reference to a particular worksheet . . . </P>
<P>counter = 1</P>
<P>Do While (oSheet.Cells(counter,1).Value &lt;&gt; "")</P>
<P>     oSheet.Cells(counter, 1).Font.Bold = True</P>
<P>     counter = counter + 1</P>
<P>Loop</P>

</FONT><FONT FACE="Arial" SIZE=2><P>If you were to examine the Excel object model documentation, you would find that:</P>

<UL>
<LI>You can apply a format to a range of multiple cells.</LI>
<LI>The object model provides you with a property (<B>UsedRange</B>), that returns a <B>Range</B> object representing the "used" cells on the worksheet.</LI>
<LI>You can use the <B>Resize</B> method to resize a range X rows by X columns. </LI></UL>

<P>Armed with this knowledge, you can rewrite your code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oSheet.Cells(1,1).Resize(oSheet.UsedRange.Rows.Count, 1).Font.Bold = True</P>

</FONT><FONT FACE="Arial" SIZE=2><P>This makes a significant improvement in your Automation code if you have a relatively large range of "used" cells to format.</P>
<P>Now consider a repetitive task you could simplify while automating Microsoft PowerPoint. If you had a slide with three shapes to which you wanted to apply the same text formats, you might try code similar to the following to format all three shapes:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>'Where oSlide represents a Slide object . . .</P>

<P>With oSlide.Shapes("Text Box 2").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 3").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

<P>With oSlide.Shapes("Text Box 4").TextFrame.TextRange.Font</P>
<P>    .Name = "Arial"</P>
<P>    .Size = 16</P>
<P>    .Bold = True</P>
<P>End With</P>

</FONT><FONT FACE="Arial" SIZE=2><P>However, if you were to examine the object model documentation for Microsoft PowerPoint, you would find that there is a way to format all three shapes at once by using a <B>ShapeRange</B> object that represents multiple shapes. You can simplify your code with:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P> 'Where oSlide represents a Slide object . . .</P>
<P> Dim oShapes As ShapeRange</P>
<P> Set oShapes = oSlide.Shapes.Range( _<BR>
                    Array("Text Box 2", "Text Box 3", "Text Box 4"))</P>
<P> With oShapes.TextFrame.TextRange.Font</P>
<P>     .Name = "Arial"</P>
<P>     .Size = 16</P>
<P>     .Bold = True</P>
<P> End With</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As you can see, there are benefits to finding ways to improve repetitive tasks. Understandably, it is difficult to know every single detail of an Automation server's object model and the features that it exposes. However, with a little research into the object model documentation and forethought regarding repetitive tasks you are automating, you can improve your Automation code and simplify some of the tasks you undertake.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Tip #5 – Minimize Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To improve the performance of your code, you should minimize interface requests whenever possible. Because of the manner by which a C/C++ or MFC programmer writes Automation code, this is not as much of an issue as it is for Visual Basic programmers. Visual Basic provides the programmer the ability to drill down to many levels within the object model in a single statement. When writing Automation code, it is important to keep in mind how drilling down from one object to another affects the number of interfaces you are requesting from the Automation server. Consider this example that drills down from Excel's <B>Application</B> object to a <B>Range</B> object:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1").Cells(1,1).Value = 5</P>

</FONT><FONT FACE="Arial" SIZE=2><P>In this single line of code, you are requesting five interfaces: one interface each for a <B>Workbooks</B> collection object, a <B>Workbook</B> object, a <B>Worksheets</B> collection object, a <B>Worksheet</B> object, and a <B>Range</B> object. If this were the only line of code where you were accessing a range on this particular sheet, this would really not make a big difference in the larger scheme of things. But what if the following code is nested in a loop?</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>For counter = 1 to 100</P>
<P>     oApp.Workbooks.Item("Book1").Worksheets.Item( _</P>
<P>                                "Sheet1").Cells(counter,1).Value = 5</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>In this loop, you would be making 5 x 100, for a total of 500 interface requests, which is a large number for this small portion of code. You can improve this number by setting object variables for items that you use frequently. In this particular example, you can benefit from setting an object variable for the worksheet that you are populating with data. Consider the following code that provides you with the same results:</P>

</FONT><FONT FACE="Courier New" SIZE=2><P>Dim oSheet as Excel.Worksheet</P>

<P>Set oSheet = _</P>
<P>  oApp.Workbooks.Item("Book1").Worksheets.Item("Sheet1") '4 Requests</P>

<P>For counter = 1 to 100</P>
<P>  oSheet.Cells(counter,1).Value = 5   '1 Request</P>
<P>Next</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>With this improved code, you make 4 + (100 x 1), a total of 114 interface requests. When you compare 114 to 500 interface requests, you recognize a significant improvement and a very important one because it can greatly increase the performance of your Automation code. </P><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Windows 95/98 Limitation on Interface Requests</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There is another attraction to minimizing your interface requests. When automating any ActiveX component, there is a limit to the number of interface requests you can make within a tight loop on Windows 95 and Windows 98. This limit is roughly 64K. If you write code that comes close to this limit or exceeds this limit, you might experience any of the following:</P></DIR>


<UL>

<UL>
<LI>Your Automation server hangs.</LI>
<LI>You receive "Out of memory" errors.</LI>
<LI>Your Automation server remains in memory even after your application ends.</LI></UL>
</UL>
<DIR>

<P>To avoid this limit, employ these techniques whenever possible:</P></DIR>


<UL>

<UL>
<LI>Use arrays and call methods and properties on multiple objects at once rather than on individual objects.</LI>
<LI>Set variables for Automation objects that you frequently reference or reference in a loop.</LI>
<LI>Use the features of the Automation server to your advantage.</LI></UL>
</UL>
<DIR>

<P>For more details on this Windows 95 and Windows 98 limitation, refer to the following article in the Microsoft Knowledge Base:</P>
<P> Q216400 PRB: Cross-Process COM Automation Hangs Client App on Win95/Win98 <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q216/4/00.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q216/4/00.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Handling events in the Automation server</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Up to this point, your communication has pretty much been one way; your Automation clients have completely directed the Automation server and the server has not communicated anything back to the client. You can use <I>events</I> to allow the Automation server to notify the client when certain actions occur. By trapping these events, you enable two-way communication between the client and the server.</P>
<P>The Microsoft Visual Basic and MFC Automation clients you create in this section trap an event in Microsoft Excel that occurs when data in a cell is changed. Your client examines the data in the changed cell and applies a format to the cell based on the new data that is entered.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using WithEvents in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>An object that raises events is called an <I>event source</I>. To handle the events raised by an event source, you can declare a variable of the object's class using the <B>WithEvents</B> keyword. In this example, <B>WithEvents</B> specifies that the variable </FONT><FONT FACE="Courier New" SIZE=2>xlSheet</FONT><FONT FACE="Arial" SIZE=2> is used to handle a Worksheet object's events:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><P>There are some limitations to <B>WithEvents</B>: </P>

<UL>
<LI>You cannot declare a <B>WithEvents</B> variable as type <B>Object</B>. You must specify the class name when you declare the variable; therefore, you must use early binding to trap events for Automation servers.</LI>
<LI>You cannot declare a <B>WithEvents</B> variable as <B>New</B>. </LI>
<LI>You cannot declare <B>WithEvents</B> variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.</LI></UL>

<P>When you declare a variable using <B>WithEvents</B>, the variable name appears in the Object list of the module's code window. When you select the variable in the list, the events exposed by that class appear in the Procedure list of the module's code window. Figure 10 illustrates.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 10:   When you declare a variable WithEvents, the object appears in the Object list and the object's exposed events appear in the Procedure list.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 8: Create a Visual Basic Automation client for Microsoft Excel that traps Excel's Change event</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new Standard Exe project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the <B>Microsoft Excel 8.0</B> or <B>9.0 object library</B>.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following declarations to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim xlApp As Excel.Application</P>
<P>Dim xlBook As Excel.Workbook</P>
<P>Dim WithEvents xlSheet As Excel.Worksheet</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add code to the click event of the <B>CommandButton</B> that creates a new instance of Excel, start a new workbook with a single sheet, and then give the user control of Excel:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    'Start a new workbook in Excel and give the user control to</P>
<P>    'add/change data on the worksheet</P>
<P>    Set xlApp = New Excel.Application</P>
<P>    Set xlBook = xlApp.Workbooks.Add(xlWBATWorksheet)</P>
<P>    Set xlSheet = xlBook.Worksheets.Add</P>
<P>    xlApp.Visible = True</P>
<P>    xlApp.UserControl = True</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Click the <B>Object</B> drop-down box in the code window and select <B>xlSheet</B> from the list. Then, click the <B>Procedure</B> drop-down box in the code window and select <B>Change</B> from the list. This displays the skeleton of the <B>Change</B> event for the <B>Worksheet</B> object. Add the following code for the event: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub xlSheet_Change(ByVal Target As Excel.Range)</P>
<P>    Dim xlRng As Excel.Range</P>
<P>    'Examine the contents of a range when the contents</P>
<P>    'change</P>
<P>    For Each xlRng In Target</P>
<P>        If xlApp.WorksheetFunction.IsNumber(xlRng) Then</P>
<P>            'Format numbers &lt; 0 with a red font and</P>
<P>            'numbers &gt;=0 with a green font</P>
<P>            If xlRng &lt; 0 Then</P>
<P>                xlRng.Font.Color = RGB(255, 0, 0)</P>
<P>            Else</P>
<P>                xlRng.Font.Color = RGB(0, 255, 0)</P>
<P>            End If</P>
<P>        Else</P>
<P>            'Format non-numeric cells with a blue font</P>
<P>            xlRng.Font.Color = RGB(0, 0, 255)</P>
<P>        End If</P>
<P>    Next</P>
<P>End Sub</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Press F5 to run the application.</LI>
<LI>Click <B>Command</B>. Excel starts with a new workbook that contains a single sheet. Add different types of data to cells on the worksheet. Note that when you enter data, the data is formatted according to the value you entered.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Using Connection Points with C++ and MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To this point in our discussion, all of the communication from your C++ and MFC Automation clients has been one-way communication. In other words, the COM object interfaces that you have used thus far have all been <I>incoming</I> interfaces. Some COM objects also support <I>outgoing</I> interfaces; it is these <I>outgoing</I> interfaces that allow the object to notify clients when certain events occur.  These event notifications are handled through <I>connection</I> points.</P>
<P>Event notifications from the Automation server to the Automation client are supported by two interfaces: <B>IConnectionPointContainer</B> and <B>IConnectionPoint</B>. An Automation object that is "connectable" implements both of these interfaces for each outgoing interface that it supports.  </P>
<P>To set up event notifications in your Automation client, you can:</P>

<UL>
<LI>Implement the connectable object's <B>IDispatch</B> interface in your client.</LI>
<LI>Call <B>QueryInterface</B> on the connectable object to get a pointer to its <B>IConnectionPointContainer</B> interface.</LI>
<LI>Call <B>IConnectionPointContainer::FindConnectionPoint()</B> to obtain a pointer to the <B>IConnectionPoint</B> interface for the events you want to sink.</LI>
<LI>Call <B>IConnectionPoint::Advise()</B> to establish a connection with the connectable object by providing a pointer to your implementation of its interface.</LI></UL>


</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 9: Create an MFC Automation client for Microsoft Excel that traps Excel's Change event</P>
</FONT><FONT FACE="Arial" SIZE=2><P>To set up event notifications, you need to examine the server's type library to find the GUID for the outgoing interface as well as the DISPIDs for the events you want to catch. In the following exercise, you create an Automation client for Excel that traps a <B>Worksheet</B> object's <B>Change</B> event. By examining Excel's type library in the OLE/COM Object Viewer, you find that the outgoing interface, <B>IDocEvents</B>, has the GUID {00024411-0001-0000-C000-000000000046} and the <B>Change</B> event has the DISPID 0x609.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 11:   OLE/COM Object Viewer provides you with the information you need to connect to an outgoing interface and trap specific events.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC AppWizard .exe that is dialog-based and named "Exercise9.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Excel 8.0 (or 9.0) type library.</LI>
<LI>Add <B>AfxOleInit()</B> to <B>CExercise9App::InitInstance()</B> to initialize the COM library:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>    AfxMessageBox("Could not initialize COM services.");</P>
<P>    return FALSE;</P>
<P>}</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add a new C/C++ header file to the project. Name the header file ExcelEventSink.h. This file contains the <B>IDispatch</B> implementation for the <B>Worksheet</B> events sink. Add the following code to the header file:</LI>

</FONT><FONT FACE="Courier New" SIZE=1><P>#include "excel8.h"  //or "excel9.h" for Excel 2000</P>

<P>// IDispatch implementation to catch Excel's events.</P>
<P>class CExcelEventSink : public IDispatch</P>
<P>{</P>
<P>public:</P>
<P>ULONG refCount;</P>

<P>CExcelEventSink::CExcelEventSink() {</P>
<P>   refCount = 1;</P>
<P>}</P>
<P>CExcelEventSink::~CExcelEventSink() {</P>
<P>}</P>

<P>// IUnknown methods.</P>
<P>virtual HRESULT __stdcall QueryInterface(</P>
<P>      REFIID riid, void **ppvObject) {</P>
<P>   if(</P>
<P>      IsEqualGUID(riid, IID_IDispatch) ||</P>
<P>      IsEqualGUID(riid, IID_IUnknown)</P>
<P>   ) {</P>
<P>      this-&gt;AddRef();</P>
<P>      *ppvObject = this;</P>
<P>      return S_OK;</P>
<P>   }</P>
<P>   *ppvObject = NULL;</P>
<P>   return E_NOINTERFACE;</P>
<P>}</P>

<P>virtual ULONG _stdcall AddRef(void) {</P>
<P>   return ++refCount;</P>
<P>}</P>

<P>virtual ULONG _stdcall Release(void) {</P>
<P>   if(--refCount &lt;= 0) {</P>
<P>      //Delete this;</P>
<P>      return 0;</P>
<P>   }</P>
<P>   return refCount;</P>
<P>}</P>

<P>// IDispatch methods.</P>
<P>virtual HRESULT _stdcall GetTypeInfoCount(UINT *pctinfo) {</P>
<P>   if(pctinfo) *pctinfo = 0;</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetTypeInfo(</P>
<P>      UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall GetIDsOfNames(</P>
<P>      REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid,</P>
<P>      DISPID *rgDispId) {</P>
<P>   return E_NOTIMPL;</P>
<P>}</P>

<P>virtual HRESULT _stdcall Invoke(</P>
<P>      DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,</P>
<P>      DISPPARAMS *pDispParams, VARIANT *pVarResult,</P>
<P>      EXCEPINFO *pExcepInfo, UINT *puArgErr) </P>
<P>{</P>

<P>   switch(dispIdMember) </P>
<P>   {</P>
<P>      case 0x609: // Worksheet Change Event</P>
<P>        {          </P>
<P>            //Get the target range and the font for that range</P>
<P>            Range oRange;</P>
<P>            oRange.AttachDispatch(pDispParams-&gt;rgvarg[0].pdispVal);</P>
<P>            Font oFont = oRange.GetFont();</P>

<P>            //Determine if the range is numeric</P>
<P>            _Application oApp = oRange.GetApplication();</P>
<P>            WorksheetFunction oFunc = oApp.GetWorksheetFunction();</P>
<P>            BOOL bIsNumber = oFunc.IsNumber(pDispParams-&gt;rgvarg[0]);</P>

<P>            //If it is a numeric format it with green if &gt;=0 and</P>
<P>            //red if &lt;= 0</P>
<P>            if (bIsNumber)</P>
<P>            {</P>
<P>              COleVariant vValue = oRange.GetValue();</P>
<P>              if (vValue.dblVal&gt;=0)</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF00));</P>
<P>              else</P>
<P>                  oFont.SetColor(COleVariant((long)0xFF));</P>
<P>            }</P>
<P>            //Else, set the font color to blue</P>
<P>            else</P>
<P>            {</P>
<P>              oFont.SetColor(COleVariant((long)0xFF0000));</P>
<P>            }</P>

<P>            break;</P>
<P>        }         </P>
<P>      </P>
<P>   }</P>
<P>   return S_OK;</P>
<P>}</P>

<P>};</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>Add two <B>Commands</B> to the dialog resource IDD_EXERCISE9_DIALOG and create member variables for both buttons.</LI></FONT>
<P ALIGN="LEFT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=518>
<TR><TD WIDTH="44%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>ID</B></FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Caption</B></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Member Variable</B></FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_START_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Start</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_StartExcelEvents</FONT></TD>
</TR>
<TR><TD WIDTH="44%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_END_EXCEL_EVENTS</FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>End</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>m_EndExcelEvents</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="Arial" SIZE=2>
<LI>Add the following variables and button handlers to Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>IConnectionPoint *pCPSheetEvents;</P>
<P>CExcelEventSink Sink;         </P>
<P>DWORD dwSheetEventsCookie;</P>
<P>BOOL bSinkInPlace = FALSE;</P>

<P>void CExercise9Dlg::OnStartExcelEvents() </P>
<P>{</P>
<P>    _Application oApp;</P>

<P>    if(!oApp.CreateDispatch("Excel.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Start a new workbook with exactly one sheet</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(COleVariant((short)-4167));</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>

<P>    // Declare the events you want to catch.-- in this case, you</P>
<P>    // are catching the Worksheet object events to determine</P>
<P>    // trap when the user changes data in a cell.</P>
<P>    //</P>
<P>    // IDocEvents = {00024411-0001-0000-C000-000000000046}</P>

<P>    static const GUID IID_IDocEvents =</P>
<P>        {0x00024411,0x0000,0x0000,</P>
<P>        {0xc0,0x00,0x0,0x00,0x00,0x00,0x00,0x46 } };</P>

<P>    // Get the Worksheet object's IConnectionPointContainer </P>
<P>    // interface to set up the advisory connection</P>
<P>    HRESULT hr;</P>
<P>    IConnectionPointContainer *pCPCtrSheet = NULL;</P>
<P>    hr = oSheet.m_lpDispatch-&gt;QueryInterface(</P>
<P>                     IID_IConnectionPointContainer,</P>
<P>                     (void **)&amp;pCPCtrSheet);</P>
<P>    hr = pCPCtrSheet-&gt;FindConnectionPoint(IID_IDocEvents, </P>
<P>                     &amp;pCPSheetEvents);</P>
<P>    hr = pCPSheetEvents-&gt;Advise(&amp;Sink, &amp;dwSheetEventsCookie);</P>
<P>    if (SUCCEEDED(hr))</P>
<P>        bSinkInPlace=TRUE;</P>
<P>    if (pCPCtrSheet!=NULL) pCPCtrSheet-&gt;Release();</P>

<P>    m_StartExcelEvents.EnableWindow(FALSE);</P>
<P>    m_EndExcelEvents.EnableWindow(TRUE);</P>
<P>}</P>

<P>void CExercise9Dlg::OnEndExcelEvents() </P>
<P>{</P>
<P>    if (bSinkInPlace)</P>
<P>    {</P>
<P>        //Terminate the advisory connections</P>
<P>        pCPSheetEvents-&gt;Unadvise(dwSheetEventsCookie);</P>
<P>        pCPSheetEvents-&gt;Release();</P>
<P>        bSinkInPlace = FALSE;</P>
<P>    }</P>
<P>    m_StartExcelEvents.EnableWindow(TRUE);</P>
<P>    m_EndExcelEvents.EnableWindow(FALSE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the precompiler directive to include ExcelEventSink.h in Exercise9Dlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>    #include "ExcelEventSink.h"</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application.</LI>
<LI>Click <B>Start</B> in the dialog box. Excel starts with a new workbook. Add data to cells on the sheet. Note that as you add data to cells, the sink traps the <B>Change</B> event and the changed cell is formatted based on its contents.</LI>
<LI>Click <B>End</B> in the dialog box. The connection is dropped and any changes you make later to the worksheet are unaffected by the sink.</LI></OL>

<I>
</I><B><P>NOTE</B>:  In this exercise, you provided your own implementation of <B>IDispatch</B> in the class <B>CExcelEventSink</B>. The default implementation in MFC of <B>IDispatch::Invoke()</B> does not support named arguments, so you must provide your own implementation of <B>IDispatch</B>.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automating Embedded and Linked Office Documents</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Office documents can be inserted into other containers. Containers that allow you to insert objects from other applications can create documents that contain information and data for each object they hosts. These documents are called <I>compound documents</I>. </P>
<P>The mechanism by which an application's document is inserted into a container of a different application is called OLE (Object Linking and Embedding). An OLE object that you insert into a container can be either <I>linked</I> or <I>embedded</I>. The primary difference between the two types lies in how and where the object's source data is stored.</P>
<P>When you add a link to an object, the source data for that object continues to reside wherever it was initially created. With a <I>linked object</I>, the compound document contains only a reference to the actual data along with information about how to present that data. In contrast, all the data in an <I>embedded object</I> is physically stored in the compound document.</P>
<P>Both linked and embedded objects have their advantages:</P>

<UL>
<LI>The storage required in a compound document is less for a <I>linked</I> object when compared to an <I>embedded</I> object.</LI>
<LI>When you make changes to an <I>embedded</I> object, the changes are applied only to the object contained within the compound document. In contrast, when you make changes to a linked object in a compound document, you are actually changing the source document's data, and the information about that link is updated in the compound document.</LI>
<LI>When you change the source data for a <I>linked</I> object, the <I>linked</I> object in the compound document can be updated to reflect the changes in the source. On the other hand, objects that are <I>embedded</I> from a source are unaffected by changes to the source.</LI>
<LI>Compound documents that contain <I>embedded</I> objects can be transferred to other locations without concern for breaking links because no link information is stored for <I>embedded</I> objects.</LI>
<I><LI>Embedded</I> objects can be in-place activated in the container. <I>Linked</I> objects cannot be in-place activated; instead, the document must be opened with the server in a separate window.</LI></UL>

<P>Many applications that can host OLE objects, including the Office applications, provide you with a standard dialog box for inserting OLE objects (Figure<I> </I>12). When presented with this dialog box, you can choose <B>Create New </B>and select an object type from the list to insert an object that is embedded. Or, you can choose <B>Create From File</B> and browse to a file. When you insert an object based on a file, you have the option of creating a link.</P>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 12:   The Insert Object dialog box is commonly used to embed or link an object.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>MFC and Visual Basic applications can support containers that host linked and embedded objects. Provided that the object's OLE server supports Automation, the application hosting the object can access the object's OLE server at run time to manipulate the object. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Using the OLE Container in Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The <B>OLE Container</B> control provides Visual Basic applications with the ability to display OLE objects on a form. With the <B>OLE Container</B>, you can insert linked or embedded objects, activate and edit objects, and even automate OLE objects.  To automate an object contained in an <B>OLE Container</B> control, you use its <B>Object</B> property. For example, if you have an <B>OLE Container</B> (named OLE1) that contains a Microsoft Word document, you can automate Word to make changes to the document using the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oDoc as Word.Document</P>
<P>Set oDoc = OLE1.Object</P>
<P>oDoc.TypeText "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>As another example, consider an <B>OLE Container</B> that contains a Microsoft Excel workbook. To automate that workbook, you could use the following code:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oBook as Excel.Workbook</P>
<P>Dim oApp as Excel.Application</P>
<P>Set oBook = OLE1.Object</P>
<P>Set oApp = oBook.Application</P>
<P>oApp.ActiveSheet.Range("A1").Value = "Hello World"</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>For more sample code and information about using the OLE Container in Visual Basic to embed and automate Office documents, please see the following article in the Microsoft Knowledge Base:</P>
<P> Q242243 HOWTO: Embed and Automate Office Documents with Visual Basic <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q242/2/43.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q242/2/43.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 10: Embed and Automate an Excel Chart with Visual Basic</P>
</FONT><FONT FACE="Arial" SIZE=2><P>In this exercise, you use the <B>OLE Container</B> control on a Form in Visual Basic to embed a new Microsoft Excel Chart. Once the object is embedded, you begin to automate it by calling the <B>Object</B> property of the <B>OLE Container</B> to obtain a reference to the <B>Workbook</B> that is contained. </P>
<B><P>NOTE</B>: Although the object that you embed has the PROGID "Excel.Chart," the document that is actually embedded is a workbook that contains both a chart sheet and a worksheet. Therefore, the document that is returned from the <B>Object</B> property is type <B>Workbook</B>. Once Automation is complete, the <B>OLE Container</B> displays an Excel XY-Scatter chart that resembles the one illustrated in Figure 13.</P>
<DIR>

</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 13:   An OLE Container on a Visual Basic form that contains a Microsoft Excel chart</P>
</B></FONT><FONT FACE="Arial" SIZE=2></DIR>

<OL>

<LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Excel object library.</LI>
<LI>Add an <B>OLE Container</B> control to Form1. When prompted to select an object type, click <B>Cancel</B> because, in this sample, you set the object type at run time.</LI>
<LI>Set the <B>OLE Container</B> control's <B>SizeMode</B> property to <B>3-Zoom</B> and its <B>Visible</B> property to <B>False</B>.</LI>
<LI>Add two <B>CommandButtons</B> to Form1. Set the <B>Caption</B> property for <B>Command1</B> to <B>Create Chart</B>. Set the <B>Caption</B> property for <B>Command2 </B>to <B>Update Chart</B>. Also set the <B>Enabled </B>property of <B>Command2 </B>to <B>False</B>.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub Command1_Click()</P>
<P>    </P>
<P>    'Embed a new Excel chart</P>
<P>    OLE1.CreateEmbed "", "excel.chart"</P>
<P>    </P>
<P>    'Get an object reference to the chart object and the worksheet </P>
<P>    'object so that you can change the chart and the data</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Dim oChart As Excel.Chart</P>
<P>    Set oBook = OLE1.object</P>
<P>    Set oChart = oBook.Charts(1)</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Clear all the cells on the worksheet and</P>
<P>    'then add your data to the worksheet</P>
<P>    oSheet.Cells.Clear</P>
<P>    oSheet.Range("A1:C1").Value = Array("X", "Y1", "Y2")</P>
<P>    oSheet.Range("A2:C10").Formula = "=RAND()"</P>
<P>    </P>
<P>    'Set the sourcedata for the chart to range "A1:C10"</P>
<P>    'and change the chart type to xy-scatter</P>
<P>    oChart.ChartType = xlXYScatterLines</P>
<P>    oChart.SetSourceData oSheet.Range("A1:C10"), xlColumns</P>
<P>    </P>
<P>    'Add the chart title and remove the legend</P>
<P>    oChart.HasTitle = True</P>
<P>    oChart.ChartTitle.Text = "Sample XY Scatter Chart"</P>
<P>    oChart.HasLegend = False</P>
<P>    </P>
<P>    'For the axes, change the 1) major units so that the scale</P>
<P>    'for the chart appears in increments of 0.25, 2) change</P>
<P>    'the maximum of the scale and 3) format the axis labels to</P>
<P>    'show two decimal places, 4) add major gridlines</P>
<P>    With oChart.Axes(xlValue)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    With oChart.Axes(xlCategory)</P>
<P>        .MajorUnit = 0.25</P>
<P>        .TickLabels.NumberFormat = "0.00"</P>
<P>        .TickLabels.Font.Size = 9</P>
<P>        .MaximumScale = 1</P>
<P>        .HasMajorGridlines = True</P>
<P>    End With</P>
<P>    </P>
<P>    'Change the color of the plot area and the series</P>
<P>    oChart.PlotArea.Interior.ColorIndex = 19</P>
<P>    With oChart.SeriesCollection(1)</P>
<P>        .Border.ColorIndex = 21</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    With oChart.SeriesCollection(2)</P>
<P>        .Border.ColorIndex = 10</P>
<P>        .Border.Weight = xlMedium</P>
<P>        .MarkerStyle = xlNone</P>
<P>    End With</P>
<P>    </P>
<P>    OLE1.Visible = True</P>
<P>    OLE1.Close  'Deactivate the OLE container</P>
<P>    Command1.Enabled = False</P>
<P>    Command2.Enabled = True</P>
<P>    </P>
<P>End Sub</P>

<P>Private Sub Command2_Click()</P>
<P>    'Recalculate the worksheet, and thus update the chart</P>
<P>    OLE1.object.Application.Calculate</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click <B>Create Chart</B> to embed the Excel chart object and automate it. Once the chart is created, you can click <B>Update Chart</B> to recalculate the cells on the worksheet and update the chart.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Use COleClientItem with MFC</P>
</FONT><FONT FACE="Arial" SIZE=2><P>With MFC, the <B>COleClientItem</B> class defines the container interface to OLE objects. If you use the AppWizard to build your application, you can choose to provide your application with container support for compound documents and the <B>COleClientItem</B> classed is wrapped for you. </P>
<B><P>COleClientItem</B> does not provide a member function for retrieving the <B>IDispatch</B> pointer to a contained OLE object. However, the means for doing so are documented in the technical note "TN039: MFC/OLE Automation Implementation." This technical note describes a function, <B>COleClientItem::GetIDispatch()</B>, that you can use in your MFC applications to acquire the <B>IDispatch</B> pointer to an OLE object for the purpose of automating it. Exercise 11 below demonstrates use of this function to automate an embedded Excel chart.</P>
<P>For additional code samples of embedding and automating Office documents in your MFC applications, please see the following articles in the Microsoft Knowledge Base:</P>
<P>Q184663 HOWTO: Embed and Automate a Microsoft Excel Worksheet with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q184/6/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q184/6/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238611 HOWTO: Embed and Automate a Word Document with MFC <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/11.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/11.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
</FONT><FONT FACE="Arial Black" SIZE=2><P>Exercise 11: Create an MFC container that embeds and Automates a Microsoft Excel Chart</P>
</FONT><FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 14:   An embedded Microsoft Excel Chart in an MFC application</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<OL>

<LI>Create a new MFC Appwizard (EXE) named "Exercise11." </LI>
<LI>In step 1 of the AppWizard, select <B>Single document</B> as the application type.</LI>
<LI>In step 3 of the AppWizard, select <B>Container</B> for compound document support, and then click <B>Finish</B>.</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add the <B>GetIDispatch()</B> function to CntrItem.cpp. This is the function you use to return the <B>IDispatch</B> pointer for the embedded object.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH CExercise11CntrItem::GetIDispatch()</P>
<P>{</P>
<P>     //The this and m_lpObject pointers must be valid for this </P>
<P>     //function to work correctly. The m_lpObject is the IUnknown </P>
<P>     //pointer to this object.</P>
<P>     ASSERT_VALID(this);</P>
<P>     ASSERT(m_lpObject != NULL);</P>

<P>     LPUNKNOWN lpUnk = m_lpObject;</P>

<P>     //The embedded application must be running in order for the </P>
<P>     //rest of the function to work.</P>
<P>     Run();</P>

<P>     //QI for the IOleLink interface of m_lpObject.</P>
<P>     LPOLELINK lpOleLink = NULL;</P>
<P>     if (m_lpObject-&gt;QueryInterface(IID_IOleLink,</P>
<P>        (LPVOID FAR*)&amp;lpOleLink) == NOERROR)</P>
<P>     {</P>
<P>        ASSERT(lpOleLink != NULL);</P>
<P>        lpUnk = NULL;</P>

<P>        //Retrieve the IUnknown interface to the linked </P>
<P>        //application.</P>
<P>        if (lpOleLink-&gt;GetBoundSource(&amp;lpUnk) != NOERROR)</P>
<P>        {</P>
<P>           TRACE0("Warning: Link is not connected!\n");</P>
<P>           lpOleLink-&gt;Release();</P>
<P>           return NULL;</P>
<P>        }</P>
<P>        ASSERT(lpUnk != NULL);</P>
<P>     }</P>

<P>     //QI for the IDispatch interface of the linked application.</P>
<P>     LPDISPATCH lpDispatch = NULL;</P>
<P>     if (lpUnk-&gt;QueryInterface(IID_IDispatch, </P>
<P>        (LPVOID FAR*)&amp;lpDispatch)!=NOERROR)</P>
<P>     {</P>
<P>        TRACE0("Warning: does not support IDispatch!\n");</P>
<P>        return NULL;</P>
<P>     }</P>

<P>     //After assuring ourselves it is valid, return the IDispatch</P>
<P>     //interface to the caller.</P>
<P>     ASSERT(lpDispatch != NULL);</P>
<P>     return lpDispatch;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><P>Also, update CntrItem.h to accommodate the new function:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>LPDISPATCH GetIDispatch();</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a member variable that contains the bounding rectangle of the embedded OLE object. Add the following to CntrItem.h:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>CRect m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Select the <B>ResourceView </B>tab and activate the menu resource IDR_MAINFRAME. Add a new item to the <B>Edit</B> menu with the caption <B>Insert Excel Chart</B>. Also add a new item to the <B>Edit</B> menu with the caption <B>Update Chart</B>. Note that the default IDs given to the new commands are ID_EDIT_INSERTEXCELCHART and ID_EDIT_UPDATECHART, respectively.</LI>
<LI>Include the Excel wrapper classes in CExercise11View.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "excel8.h"   //or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Insert Excel Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditInsertexcelchart() </P>
<P>{</P>
<P>    CExercise11CntrItem* pItem = NULL;</P>

<P>    //Get the document associated with this view</P>
<P>    CExercise11Doc* pDoc = GetDocument();</P>

<P>    //Create a new item associated with this document</P>
<P>    pItem = new CExercise11CntrItem(pDoc);</P>

<P>    //Embed a new Excel chart</P>
<P>    CLSID clsid;</P>
<P>    ::CLSIDFromProgID(L"Excel.Chart",&amp;clsid);</P>
<P>    pItem-&gt;CreateNewItem(clsid);</P>

<P>    //Specify the dimensions for the embedded object based</P>
<P>    //on this view and store them in our member variable</P>
<P>    CRect rectView;</P>
<P>    this-&gt;GetClientRect(&amp;rectView);</P>
<P>    pItem-&gt;m_rectChart.SetRect(10, 10, rectView.right-10, </P>
<P>                               rectView.bottom-10);</P>

<P>    //Get the IDispatch pointer for the embedded object so</P>
<P>    //that you can automate it to control the chart and</P>
<P>    //the worksheet</P>
<P>    LPDISPATCH lpDisp;</P>
<P>    lpDisp = pItem-&gt;GetIDispatch();</P>

<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    _Workbook oBook;</P>
<P>    oBook.AttachDispatch(lpDisp);</P>

<P>    //Get IDispatch* for the chart sheet and the worksheet</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Charts oCharts = oBook.GetCharts();</P>
<P>    _Chart oChart = oCharts.GetItem(COleVariant((short)1));</P>

<P>    //Clear all the cells on the worksheet and then add the new</P>
<P>    //data to it</P>
<P>    Range oRng = oSheet.GetCells();</P>
<P>    oRng.Clear();</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("X"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y1"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>    oRng.SetValue(COleVariant("Y2"));</P>
<P>    oRng = oSheet.GetRange(COleVariant("A2:C10"), vOpt);</P>
<P>    oRng.SetFormula(COleVariant("=RAND()"));</P>

<P>    //Set the sourcedata for the chart to range "A1:C10" and</P>
<P>    //change the chart type to xy-scatter lines</P>
<P>    oChart.SetChartType((long)74); //xlXYScatterLines = 74</P>
<P>    oRng = oSheet.GetRange(COleVariant("A1:C10"), vOpt);</P>
<P>    oChart.SetSourceData(oRng, </P>
<P>                         COleVariant((short)2)); //xlColumns = 2</P>

<P>    //Add the chart title and remove the legend</P>
<P>    oChart.SetHasTitle(TRUE);</P>
<P>    ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>    oChartTtl.SetText("Sample XY Scatter Chart");</P>
<P>    oChart.SetHasLegend(FALSE);</P>

<P>    //For the axes, change the 1) major units so that the scale</P>
<P>    //for the chart appears in increments of 0.25, 2) change</P>
<P>    //the maximum of the scale and 3) format the axis labels to</P>
<P>    //show two decimal places, 4) add major gridlines</P>
<P>    Axis oValAxis = oChart.Axes(COleVariant((short)2), </P>
<P>                                (long)1);  //xlValue =2</P>
<P>    Axis oCatAxis = oChart.Axes(COleVariant((short)1), </P>
<P>                                (long)1);  //xlCategory = 1</P>

<P>    //The Value Axis...</P>
<P>    oValAxis.SetMajorUnit((double)0.25);</P>
<P>    TickLabels oTickLbls = oValAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    Font oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oValAxis.SetMaximumScale((double)1);</P>
<P>    oValAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //The Category Axis...</P>
<P>    oCatAxis.SetMajorUnit((double)0.25);</P>
<P>    oTickLbls = oCatAxis.GetTickLabels();</P>
<P>    oTickLbls.SetNumberFormat("0.00");</P>
<P>    oFont = oTickLbls.GetFont();</P>
<P>    oFont.SetSize(COleVariant((short)9));</P>
<P>    oCatAxis.SetMaximumScale((double)1);</P>
<P>    oCatAxis.SetHasMajorGridlines(TRUE);</P>

<P>    //Change the color of the plot area</P>
<P>    PlotArea oPlot = oChart.GetPlotArea();</P>
<P>    Interior oInt = oPlot.GetInterior();</P>
<P>    oInt.SetColorIndex(COleVariant((short)19));</P>

<P>    //Change the color and marker styles for the series</P>
<P>    Series oSeries = </P>
<P>           oChart.SeriesCollection(COleVariant((short)1));</P>
<P>    Border oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)21));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>    oSeries = oChart.SeriesCollection(COleVariant((short)2));</P>
<P>    oBorder = oSeries.GetBorder();</P>
<P>    oBorder.SetColorIndex(COleVariant((short)10));</P>
<P>    oBorder.SetWeight(COleVariant((long)-4138));//xlMedium = -4138 </P>
<P>    oSeries.SetMarkerStyle((long)-4142);        //xlNone = -4142</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>To update the member variable <B>m_rectChart</B> with the bounding rectangle of the embedded oject, you should modify <B>CExercise11View::OnDraw</B> and <B>CExercise11CntrItem::OnGetItemPosition</B>.<BR>
<BR>
Replace the following line in <B>CExercise11View::OnDraw</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, CRect(10, 10, 210, 210));</P>

</FONT><FONT FACE="Arial" SIZE=2><P>      with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>m_pSelection-&gt;Draw(pDC, m_pSelection-&gt;m_rectChart);</P>

</FONT><FONT FACE="Arial" SIZE=2><P>And replace the following line in <B>CExercise11CntrItem::OnGetItemPosition</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>rPosition.SetRect(10, 10, 210, 210);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><P>with this line:</P>
</FONT><FONT FACE="Courier New" SIZE=1><P ALIGN="RIGHT"></P>
<P>rPosition = m_rectChart;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a handler in <B>CExercise11View</B> for the <B>Update Chart</B> command using ClassWizard, and then add the following code to the handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CExercise11View::OnEditUpdatechart() </P>
<P>{</P>
<P>    if (m_pSelection != NULL)</P>
<P>    {</P>
<P>&#9;    LPDISPATCH lpDisp;</P>
<P>        lpDisp = m_pSelection-&gt;GetIDispatch();</P>
<P>        _Workbook oBook;</P>
<P>        oBook.AttachDispatch(lpDisp);</P>
<P>        _Application oApp = oBook.GetApplication();</P>
<P>        oApp.Calculate();</P>
<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. Once the application loads, on the <B>Edit</B> menu, select <B>Insert Excel Chart</B>. A new Excel chart resembling the one in Figure 14 is embedded. Once the chart is embedded, on the <B>Edit</B> menu, select <B>Update Chart</B>. Note that the data recalculates and the chart updates accordingly.</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1>
<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Sample Code for automating Microsoft Office Applications</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section contains Visual Basic and MFC sample code for automating Office applications for common tasks in an effort to illustrate how to use the different applications as Automation servers. The code has been tested against Microsoft Office 97 and Microsoft Office 2000 applications and can be used for both versions.</P>
<P>You might be referencing this section to learn how to automate a particular Office application. Keep in mind that each sample is unique and illustrates different Automation techniques. You can benefit from reviewing the discussion and sample code for servers other than the one or more that you intend to automate.</P>
<B><P>NOTE</B>: For brevity, these samples do not implement error handling.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Create and Format a New Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The first examples automate Microsoft Excel to create a new workbook and transfer data to a worksheet in the new workbook using arrays. The number of rows in the resulting data is determined at run time. Figure 15 represents the workbook's appearance after running the Automation code in this section.</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 15:   Results of the sample Automation code to create and format a new Excel workbook</P>
</B></FONT><I><FONT FACE="Arial" SIZE=2>
</I></FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Excel object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Const NUMROWS = 20</P>

<P>Private Sub Command1_Click()</P>

<P>    'Start a new workbook in Excel</P>
<P>    Dim oExcel As Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Set oExcel = New Excel.Application</P>
<P>    Set oBook = oExcel.Workbooks.Add</P>
<P>    </P>
<P>    'Get the first worksheet in the workbook so that you can</P>
<P>    'make changes to it</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add headers to Row 1 of the worksheet</P>
<P>    oSheet.Range("A1:D1").Value = Array("Date", "Order #", _<BR>
                                        "Amount", "Tax")</P>
<P>    </P>
<P>    'Create an array that is NUMROWS x 3 columns.</P>
<P>    'Column 1 will contain dates, column 2 will contain strings</P>
<P>    'and column 3 will contain numbers</P>
<P>    ReDim vArray(1 To NUMROWS, 1 To 3) As Variant</P>
<P>    Dim i As Integer</P>
<P>    For i = 1 To NUMROWS</P>
<P>        vArray(i, 1) = Format(DateSerial(1999, _</P>
<P>           (Rnd * 100) Mod 12, (Rnd * 100) Mod 28), "m/d/yy")</P>
<P>        vArray(i, 2) = "ORDR" &amp; i + 1000</P>
<P>        vArray(i, 3) = Format(Rnd * 100, "#0.00")</P>
<P>    Next</P>
<P>    </P>
<P>    'Fill a range, starting at cell A2 with the data from the array</P>
<P>    oSheet.Range("A2").Resize(NUMROWS, 3).Value = vArray</P>
<P>    </P>
<P>    'Fill the fourth column with a formula to compute the sales tax.</P>
<P>    'Note that the formula uses a "relative" cell reference so that </P>
<P>    'it fills properly</P>
<P>    oSheet.Range("D2").Resize(NUMROWS, 1).Formula = "=C2*0.07"</P>
<P>    </P>
<P>    'Format the worksheet</P>
<P>    With oSheet.Range("A1:D1")</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Excel visible and give the user control</P>
<P>    oExcel.Visible = True</P>
<P>    oExcel.UserControl = True</P>

<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the code finishes running, a new workbook in Excel appears containing data resembling the data in Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2>
<P>MFC Example</P>
<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelArrays." </LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELARRAYS_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#define NUMROWS 20</P>

<P>void CExcelArraysDlg::OnRun() </P>
<P>{</P>

<P>      // For optional arguments</P>
<P>      COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>      // Instantiate Excel</P>
<P>      _Application oApp;</P>
<P>      oApp.CreateDispatch("Excel.Application");</P>
<P>      if (!oApp)</P>
<P>      {</P>
<P>          AfxMessageBox("Cannot start Excel.");</P>
<P>          return;</P>
<P>      }</P>

<P>      //Get the Workbooks collection so that you can add a new</P>
<P>      //workbook</P>
<P>      Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>      _Workbook oBook = oBooks.Add(vOpt);</P>

<P>      //Get the Worksheets collection of the new Workbook so that</P>
<P>      //you can get the IDispatch for the first WorkSheet</P>
<P>      Worksheets oSheets = oBook.GetWorksheets();</P>
<P>      _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>

<P>      //*** ADD DATA TO THE WORKSHEET</P>

<P>      //Add Headers to Row 1 of the worksheet</P>
<P>      Range oRange;</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Date"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("B1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Order #"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("C1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Amount"));</P>
<P>      oRange = oSheet.GetRange(COleVariant("D1"), vOpt);</P>
<P>      oRange.SetValue(COleVariant("Tax"));</P>

<P>      //Create a safe array that is NUMROWS x 3 --</P>
<P>      //column 1 will contain dates column 2 will contain strings</P>
<P>      //and column 2 will contain numbers</P>
<P>      COleSafeArray sa;</P>
<P>      DWORD dwElements[2];</P>
<P>      dwElements[0]= NUMROWS;    //Number of rows</P>
<P>      dwElements[1]= 3;          //Number of columns</P>
<P>      sa.Create(VT_VARIANT, 2, dwElements);</P>

<P>      //Populate the safe array with the data</P>
<P>      long index[2];</P>
<P>      long lRow;</P>
<P>      COleVariant vTemp;</P>
<P>      COleDateTime vDateTime;</P>
<P>      CString s;</P>

<P>      for(lRow=0;lRow&lt;=NUMROWS-1;lRow++)</P>
<P>      {</P>
<P>         index[0] = lRow;   </P>
<P>         </P>
<P>         //Fill the first column with dates</P>
<P>         index[1] = 0;</P>
<P>         vDateTime.SetDate(1999, rand()%12, rand()%28);</P>
<P>         sa.PutElement(index, (COleVariant)vDateTime);</P>

<P>         //Fill the second column with strings</P>
<P>         index[1] = 1;</P>
<P>         s.Format("ORDR%d", lRow+1000);</P>
<P>         vTemp = s;</P>
<P>         sa.PutElement(index, vTemp);</P>

<P>         //Fill the third column with numbers</P>
<P>         index[1] = 2;</P>
<P>         vTemp = (long)rand();</P>
<P>         sa.PutElement(index, vTemp);</P>
<P>      }</P>

<P>      //Fill a range, starting at A2 with the data in</P>
<P>      //the safe array</P>
<P>      oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((short)NUMROWS),</P>
<P>                                  COleVariant((short)3));</P>
<P>      oRange.SetValue(sa);</P>
<P>      sa.Detach();</P>

<P>      //*** ADD FORMULAS TO THE WORKSHEET</P>

<P>      //Fill the fourth column with a formula to compute the</P>
<P>      //sales tax. Note that the formula uses a "relative"</P>
<P>      //cell reference so that it fills properly.</P>
<P>      oRange = oSheet.GetRange(COleVariant("D2"), vOpt);</P>
<P>      oRange = oRange.GetResize(COleVariant((long)NUMROWS), </P>
<P>                                COleVariant((long)1));</P>
<P>      oRange.SetFormula(COleVariant("=C2*0.07"));</P>

<P>      //*** FORMAT THE WORKSHEET</P>
<P>      oRange = oSheet.GetRange(COleVariant("A1"), COleVariant("D1"));</P>
<P>      Font oFont = oRange.GetFont();</P>
<P>      oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers</P>
<P>      oRange = oRange.GetEntireColumn();</P>
<P>      oRange.AutoFit();                    //AutoFit the columns 1:4</P>

<P>      //Make Excel visible and give the user control</P>
<P>      oApp.SetVisible(TRUE);</P>
<P>      oApp.SetUserControl(TRUE);</P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelArraysDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h"  // or "Excel9.h" for Excel 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelArraysApp::InitInstance()</B> in ExcelArrays.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>if(!AfxOleInit())</P>
<P>{</P>
<P>      AfxMessageBox("Cannot initialize COM services.");</P>
<P>      return FALSE;</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button<B> </B>you added to the dialog box. When the Automation code finishes running, you see a new workbook in Microsoft Excel containing data similar to that of Figure 15.</LI></OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For performance, using arrays to transfer data to Microsoft Excel is preferred whenever possible. However, you should be aware that there are limitations to the size of an array that you can transfer to Excel with Automation. If you have a rather large set of data to transfer to Excel, transfer the data in increments to avoid hitting Excel's limits.</P>
<P>For details on Excel's limitations with arrays, refer to the following article in the Microsoft Knowledge Base:</P>
<P>Q177991 XL: Limitations of Passing Arrays to Excel Using Automation<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q177/9/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q177/9/91.asp</FONT></A></P></DIR>

<FONT FACE="Arial Black" SIZE=3><P>Automate Excel to Add Data from a DAO Recordset to a Workbook</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section demonstrates how you can transfer data from a DAO (Data Access Objects) recordset to a worksheet in Microsoft Excel using Automation. This example returns data from the Microsoft Access Northwind Sample Database. You query the Northwind database for all of the records in the Products table and then transfer that data to a new Excel worksheet by using Excel's <B>CopyFromRecordset</B> method for a <B>Range</B> object. Note that although this sample was written for use with a sample Access database, you can use <B>CopyFromRecordset</B> with any DAO recordset generated from an ODBC data source connection, so you are not limited to using just Access data.  Figure 16 below illustrates how the data appears in the Excel workbook after running the sample Automation code In this section.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 16:   The Automation code in the examples transfer data from the Products table in the Access Northwind Sample Database to a new worksheet in Excel.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to both the Microsoft Excel type library and the Microsoft Data Access Objects (DAO) type library.</LI>
<LI>Add a <B>CommandButton </B>to Form1 and add the following code to the <B>Click</B> event of that <B>CommandButton</B>.<BR>
 <BR>
<B>NOTE</B>: The default path for the Northwind Sample Database is used in this code; the default path is "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb." Check your location of Northwind.mdb and modify the path in the code if necessary.</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    'Get the recordset from the Customer's table in Northwind</P>
<P>    Dim db As DAO.Database</P>
<P>    Dim rs As DAO.Recordset</P>
<P>    Set db = DAO.DBEngine.Workspaces(0).OpenDatabase( _</P>
<P>    "C:\Program Files\Microsoft Office\Office\Samples\Northwind.mdb")</P>
<P>    Set rs = db.OpenRecordset("Select * from Products", _</P>
<P>        dbOpenSnapshot)</P>
<P>    </P>
<P>    'Start a new workbook in Excel</P>
<P>    Dim oApp As New Excel.Application</P>
<P>    Dim oBook As Excel.Workbook</P>
<P>    Dim oSheet As Excel.Worksheet</P>
<P>    </P>
<P>    Set oBook = oApp.Workbooks.Add</P>
<P>    Set oSheet = oBook.Worksheets(1)</P>
<P>    </P>
<P>    'Add the field names in row 1</P>
<P>    Dim i As Integer</P>
<P>    Dim iNumCols As Integer</P>
<P>    iNumCols = rs.Fields.Count</P>
<P>    For i = 1 To iNumCols</P>
<P>        oSheet.Cells(1, i).Value = rs.Fields(i - 1).Name</P>
<P>    Next</P>
<P>    </P>
<P>    'Add the data starting at cell A2</P>
<P>    oSheet.Range("A2").CopyFromRecordset rs</P>
<P>    </P>
<P>    'Format the header row as bold and autofit the columns</P>
<P>    With oSheet.Range("a1").Resize(1, iNumCols)</P>
<P>        .Font.Bold = True</P>
<P>        .EntireColumn.AutoFit</P>
<P>    End With</P>
<P>    </P>
<P>    oApp.Visible = True</P>
<P>    oApp.UserControl = True</P>
<P>    </P>
<P>    'Close the Database and Recordset</P>
<P>    rs.Close</P>
<P>    db.Close</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton.</B> When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "ExcelData."</LI>
<LI>Using ClassWizard, add the wrapper classes for the Excel type library.</LI>
<LI>Add a button to the dialog resource IDD_EXCELDATA_DIALOG and add the following code to the button's handler in ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>//For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>    CDaoDatabase db;</P>
<P>    CDaoRecordset rs;</P>
<P>    long lNumCols;</P>

<P>    //Get a recordset that represents all the records in the Products </P>
<P>    //table of the sample Northwind database</P>
<P>    db.Open("C:\\Program Files\\Microsoft Office\\Office" \</P>
<P>            "\\Samples\\Northwind.mdb", FALSE, FALSE);</P>
<P>    rs.m_pDatabase = &amp;db;    </P>
<P>    rs.Open(AFX_DAO_USE_DEFAULT_TYPE, "Select * From Products", 0);</P>
<P>    lNumCols = rs.GetFieldCount();</P>

<P>    //Start a new workbook in Excel</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Excel.Application");</P>
<P>    if (!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Excel");</P>
<P>        return;</P>
<P>    }</P>
<P>    Workbooks oBooks = oApp.GetWorkbooks();</P>
<P>    _Workbook oBook = oBooks.Add(vOpt);</P>
<P>    Worksheets oSheets = oBook.GetWorksheets();</P>
<P>    _Worksheet oSheet = oSheets.GetItem(COleVariant((short)1));</P>
<P>    Range oRange;</P>

<P>    //Transfer the data in the recordset to the worksheet</P>
<P>    COleDispatchDriver rs2;</P>
<P>    rs2.AttachDispatch((LPDISPATCH) rs.m_pDAORecordset);</P>
<P>    oRange = oSheet.GetRange(COleVariant("A2"), vOpt);</P>
<P>    oRange.CopyFromRecordset((LPUNKNOWN) rs2.m_lpDispatch,</P>
<P>                             vOpt, vOpt);</P>
<P>    rs2.DetachDispatch();</P>
<P>    rs2.ReleaseDispatch();</P>

<P>    //Add the field names to row 1</P>
<P>    CDaoFieldInfo FieldInfo;</P>
<P>    for(long i=0; i&lt;=lNumCols-1;i++)</P>
<P>    {</P>
<P>        oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>        oRange = oRange.GetOffset(vOpt, COleVariant(i));</P>
<P>        rs.GetFieldInfo(i, FieldInfo, AFX_DAO_PRIMARY_INFO);</P>
<P>        oRange.SetValue(COleVariant(FieldInfo.m_strName));</P>
<P>    }</P>

<P>    //Format the worksheet</P>
<P>    oRange = oSheet.GetRange(COleVariant("A1"), vOpt);</P>
<P>    oRange = oRange.GetResize(COleVariant((short)1), </P>
<P>                              COleVariant(lNumCols));</P>
<P>    Font oFont = oRange.GetFont();</P>
<P>    oFont.SetBold(COleVariant((short)TRUE));</P>
<P>    oRange = oRange.GetEntireColumn();</P>
<P>    oRange.AutoFit();</P>

<P>    //Make Excel visible and give the user control</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>    oApp.SetUserControl(TRUE);</P>
<P>    </P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to ExcelDataDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "Excel8.h" //or "Excel9.h" for Excel 2000</P>
<P>#include &lt;afxdao.h&gt;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CExcelDataApp::InitInstance()</B> in ExcelData.cpp to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see the contents of the Products table in a new worksheet in Microsoft Excel.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Additional Notes</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you are using Microsoft Excel 2000, you can use either a DAO or ADO recordset with the <B>CopyFromRecordset</B> method. The Excel 97 <B>CopyFromRecordset</B> method supports only DAO recordsets.</P>
<P>For additional information on using and ADO recordset witht the CopyFromRecordset method, please see the following Microsoft Knowledge Base article:</P>
<P>Q246335: HOWTO:Transfer Data from ADO Recordset to Excel with Automation</P>
<P>http://support.microsoft.com/support/kb/articles/Q246/3/35.asp</P></DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate Word to Perform a Mail Merge with Access Data</P>
</FONT><FONT FACE="Arial" SIZE=2><P>This section illustrates how you can create form letters in Microsoft Word using data from a database. This sample uses the Northwind Sample Database but you can create a mail merge in Word with data from any database for which you have an ODBC driver installed. </P>
<P>The following code samples create form letters based on a query of the "Customers" table in Northwind. The samples create a form letter for each record in the resulting query. The results resemble those in Figure 17.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 17:    Automating Word to create a mail merge from data in an ODBC database.</P>
</B></FONT><FONT FACE="Arial" SIZE=2>
<P>To create a mail merge with external data in Microsoft Word, you must create a User DSN for the <B>OpenDataSource</B> method of Word's <B>MailMerge</B> object. The sample code uses a DSN named "Northwind" that refers to Northwind.mdb. Before using the sample code, you must first create the DSN:</P>
<OL>

<OL>

<LI>In <B>Control Panel</B> in Windows, double-click the <B>ODBC Data Sources (32-bit)</B> icon. The ODBC Data Source Administrator dialog box appears.</LI>
<LI>Click <B>Add</B> on the <B>User DSN </B>tab.</LI>
<LI>Select the <B>Microsoft Access Driver,</B> and click <B>Finish</B>.</LI>
<LI>When prompted for the new Data Source information, type <B>Northwind </B>for the name of the Data Source, and click <B>Select </B>to browse to Northwind.mdb. </LI>
<LI>Click <B>OK </B>to save the DSN information and then exit the ODBC Data Source Administrator.</LI></OL>
</OL>

<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Example</P>
</FONT><FONT FACE="Courier New" SIZE=1></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Reference the Microsoft Word object library.</LI>
<LI>Add a <B>CommandButton</B> to Form1 and add the following code to the <B>Click</B> event of that new <B>CommandButton</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    Dim oApp As New Word.Application</P>
<P>    Dim oMainDoc As Word.Document</P>
<P>    Dim oSel As Word.Selection</P>
<P>    </P>
<P>    'Start a new main document for the mail merge</P>
<P>    Set oMainDoc = oApp.Documents.Add</P>
<P>    </P>
<P>    With oMainDoc.MailMerge</P>
<P>        .MainDocumentType = wdFormLetters</P>
<P>        </P>
<P>        'Set up the mail merge data source to the DSN "Northwind"</P>
<P>        .OpenDataSource Name:="", Connection:= "DSN=Northwind", _</P>
<P>               SQLStatement:= "SELECT CompanyName, Address, " &amp; _</P>
<P>               "ContactName, City, Country, Region FROM Customers"</P>
<P>        </P>
<P>        'Add the field codes to the document to create </P>
<P>        'the form letter</P>
<P>        With .Fields</P>
<P>            Set oSel = oApp.Selection  'Reduces interface requests</P>
<P>            .Add oSel.Range, "CompanyName"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "Address"</P>
<P>            oSel.TypeParagraph</P>
<P>            .Add oSel.Range, "City"</P>
<P>            oSel.TypeText ", "</P>
<P>            .Add oSel.Range, "Country"</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Dear "</P>
<P>            .Add oSel.Range, "ContactName"</P>
<P>            oSel.TypeText ","</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText " This letter is to inform you..."</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeParagraph</P>
<P>            oSel.TypeText "Sincerely, John Smith"</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'Perform the mail merge to a new document</P>
<P>    With oMainDoc</P>
<P>        .MailMerge.Destination = wdSendToNewDocument</P>
<P>        .MailMerge.Execute Pause:=False</P>
<P>    End With</P>
<P>    </P>
<P>    'Make Word visible so that the user can see the new</P>
<P>    'mail merge document</P>
<P>    oApp.Visible = True</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B>. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table in the Northwind Sample Database.</LI></OL>
</OL>
<DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "MailMerge."</LI>
<LI>Using ClassWizard, add all of the wrapper classes for the Word type library.</LI>
<LI>Add a button to the dialog resource IDD_MAILMERGE_DIALOG and add the following code to the button's handler in MailMergeDlg.cpp:</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

<P>    //For optional arguments</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>

<P>&nbsp;</P>
<P>    //Start Word</P>
<P>    _Application oApp;</P>
<P>    oApp.CreateDispatch("Word.Application");</P>
<P>    if(!oApp)</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot start Word.");</P>
<P>        return;</P>
<P>    }</P>

<P>    //Get the Documents collection so that you can add</P>
<P>    //a new Document for the mail merge "main document"</P>
<P>    Documents oDocs = oApp.GetDocuments();</P>
<P>    _Document oDoc = oDocs.Add(vOpt, vOpt);</P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word 2000. If</P>
<P>    //you wrapped the classes from the Word type library (msword9.olb),</P>
<P>    //modify the Add method to provide 4 optional arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>    //Get the MailMerge property of the new document</P>
<P>    MailMerge oMMerge = oDoc.GetMailMerge();</P>
<P>    </P>
<P>    //Set the document type as Form Letters</P>
<P>    oMMerge.SetMainDocumentType((long)0);   //wdFormLetters = 0</P>

<P>    //Set up the mail merge data source to the DSN "Northwind" and</P>
<P>    //an SQL statement</P>
<P>    CString sSQL;</P>
<P>    sSQL ="SELECT CompanyName, Address, ContactName, City, Country," \</P>
<P>          "Region FROM Customers";</P>
<P>    oMMerge.OpenDataSource("", vOpt, vOpt, vOpt, vOpt,</P>
<P>                           vOpt, vOpt, vOpt, vOpt, vOpt, vOpt,</P>
<P>                           COleVariant("DSN=Northwind"), </P>
<P>                           COleVariant(sSQL), vOpt);</P>

<P>    //Add the field codes and text to the document</P>
<P>    Selection oSel = oApp.GetSelection();</P>
<P>    Range oRange;</P>

<P>    MailMergeFields oMMFlds = oMMerge.GetFields();</P>
<P>    MailMergeField oMMFld;</P>

<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "CompanyName");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Address");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "City");</P>
<P>    oSel.TypeText(", ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "Country");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Dear ");</P>
<P>    oRange = oSel.GetRange();</P>
<P>    oMMFld = oMMFlds.Add(oRange, "ContactName");</P>
<P>    oSel.TypeText(",");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("This letter is to inform you...");</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeParagraph();</P>
<P>    oSel.TypeText("Sincerely, John Smith");</P>

<P>    //Execute the mail merge and then close the</P>
<P>    //main document without saving changes</P>
<P>    oMMerge.SetDestination(0); //wdSendToNewDocument = 0</P>
<P>    oMMerge.Execute(COleVariant((short)FALSE));</P>
<P>    oDoc.Close(COleVariant((short)FALSE), vOpt, vOpt);</P>

<P>    //Make Word visible</P>
<P>    oApp.SetVisible(TRUE);</P>
<P>&#9;</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following include to MailMergeDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSWord8.h"  //or "msword9.h" for Word 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CMailMergeApp::InitInstance()</B> in <B>MailMerge.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. When the Automation code finishes running, you see a new document in Microsoft Word that consists of one form letter for each record in the Customers table.</LI></OL>
</OL>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate PowerPoint to Create and Run a Slide Show</P>
</FONT><FONT FACE="Arial" SIZE=2><P>The next examples demonstrate how you can create a PowerPoint presentation and then view the slide show at run time. Throughout this process, the PowerPoint application itself remains hidden. The sample creates three slides as shown in Figure 18. The first slide contains two shapes with text, the second slide contains an embedded Microsoft Graph chart, and the third slide contains WordArt.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 18:   Automate PowerPoint to create and view a slide show at run time.</P>
</FONT><FONT FACE="Arial" SIZE=1>
</B></FONT><FONT FACE="Arial" SIZE=2><P>In this example, you modify the embedded Microsoft Graph object on the second slide; in other words, you automate Microsoft Graph as well as PowerPoint. To automate both, you need to use both the type library for Microsoft Graph and the type library for PowerPoint.</P>
<B><P>Note to MFC Programmers</B>: Microsoft Graph and Microsoft PowerPoint contain classes with the same name. Use ClassWizard to generate wrapper classes from both type libraries. To avoid compile errors due to name conflicts, use a <I>namespace</I> for the wrapper classes for Microsoft Graph.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Visual Basic Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add references to both the Microsoft Graph and the Microsoft PowerPoint type libraries.</LI>
<LI>Add a <B>CommandButton</B> to Form1.</LI>
<LI>Add the following code to the module for Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds _</P>
<P>    As Long)</P>

<P>Private Sub Command1_Click()</P>

<P>    Dim oPPT As PowerPoint.Application</P>
<P>    Dim oPres As PowerPoint.Presentation</P>
<P>    Dim oSlide As PowerPoint.Slide</P>
<P>    </P>
<P>    'Create a new presentation in PowerPoint</P>
<P>    Set oPPT = New PowerPoint.Application</P>
<P>    Set oPres = oPPT.Presentations.Add(True)</P>

<P>    'SLIDE #1</P>
<P>    'Add a slide with a title</P>
<P>    Set oSlide = oPres.Slides.Add(1, ppLayoutTitle)</P>
<P>    oSlide.Shapes("Rectangle 2").TextFrame.TextRange.Text = _</P>
<P>        "Automating PowerPoint"</P>
<P>    oSlide.Shapes("Rectangle 3").TextFrame.TextRange.Text = _</P>
<P>        "To Create and View a Slideshow!"</P>
<P>    </P>
<P>    'SLIDE #2</P>
<P>    'Add a slide with an MSGraph chart.  Add data for the chart </P>
<P>    'and format it with the Pie Chart style</P>
<P>    Set oSlide = oPres.Slides.Add(2, ppLayoutBlank)</P>
<P>    Dim oShape As PowerPoint.Shape</P>
<P>    Set oShape = oSlide.Shapes.AddOLEObject(20, 20, 660, 500, _</P>
<P>        "MSGraph.Chart")</P>
<P>    </P>
<P>    Dim oGraph As Graph.Chart</P>
<P>    Set oGraph = oShape.OLEFormat.Object</P>
<P>    With oGraph.Application.DataSheet</P>
<P>        .Cells.Delete</P>
<P>        .Cells(1, 2).Value = "John":    .Cells(2, 2).Value = 520</P>
<P>        .Cells(1, 3).Value = "Sue":     .Cells(2, 3).Value = 660</P>
<P>        .Cells(1, 4).Value = "Bill":    .Cells(2, 4).Value = 690</P>
<P>    End With</P>
<P>    oGraph.ChartType = xlPie</P>
<P>    oGraph.HasTitle = True</P>
<P>    oGraph.ChartTitle.Text = "Acme Corporation"</P>
<P>    oGraph.PlotArea.Border.LineStyle = xlLineStyleNone</P>
<P>    oGraph.Legend.Position = xlLegendPositionBottom</P>
<P>    oGraph.Application.Update</P>
<P>    oGraph.Application.Quit</P>
<P>    </P>
<P>    'SLIDE #3</P>
<P>    'Add another slide with Text Effects</P>
<P>    Set oSlide = oPres.Slides.Add(3, ppLayoutBlank)</P>
<P>    oSlide.Shapes.AddTextEffect 27, "The End", "Impact", _</P>
<P>           100, False, False, 200, 200</P>
<P>    'Note: msoTextEffect28 = 27</P>
<P>        </P>
<P>    'Apply a color scheme to all slides and apply slideshow </P>
<P>    'settings to all slides</P>
<P>    With oPres.Slides.Range</P>
<P>        .ColorScheme = oPres.ColorSchemes(3)</P>
<P>        With .SlideShowTransition</P>
<P>           .EntryEffect = ppEffectBlindsVertical</P>
<P>            .AdvanceOnTime = True</P>
<P>            .AdvanceTime = 3</P>
<P>        End With</P>
<P>    End With</P>
<P>    </P>
<P>    'View the slide show</P>
<P>    Sleep 500</P>
<P>    With oPres.SlideShowSettings</P>
<P>        .AdvanceMode = ppSlideShowUseSlideTimings</P>
<P>        .Run</P>
<P>    End With</P>
<P>    </P>
<P>    'Wait until there are no more slide show windows and then quit </P>
<P>    'PowerPoint</P>
<P>    Do</P>
<P>        Sleep 1000</P>
<P>    Loop While oPPT.SlideShowWindows.Count &gt; 0</P>
<P>    oPPT.Quit</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application and click the <B>CommandButton</B> on Form1. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation is closed and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Example</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new dialog-based MFC AppWizard EXE project named "SlideShow." </LI>
<LI>Using ClassWizard, add all of the wrapper classes for both the Microsoft Graph and Microsoft PowerPoint type libraries.</LI>
<LI>Because the wrapper classes for Microsoft Graph have the same name as wrapper classes for PowerPoint, encapsulate the wrapper classes for Microsoft Graph in a namespace in both Msgraph8.h and Msgraph8.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>namespace MSGraph</P>
<P>{</P>

<P>. . . </P>

<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Add a button to the dialog resource IDD_SLIDESHOW_DIALOG and add the following code to the button's handler in SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR); //For optional args</P>

<P>_Application oApp;</P>

<P>if(!oApp.CreateDispatch("Powerpoint.Application", NULL))</P>
<P>{</P>
<P>    AfxMessageBox("Cannot start PowerPoint", MB_SETFOREGROUND);</P>
<P>    return;</P>
<P>}</P>

<P>Presentations oPresSet = oApp.GetPresentations();</P>
<P>_Presentation oPres = oPresSet.Add(true);</P>

<P>//SLIDE #1 ======================================================</P>

<P>//Add a slide with a title</P>
<P>Slides oSlides = oPres.GetSlides();</P>
<P>_Slide oSlide = oSlides.Add(1, 1);  //ppLayoutTitle = 1</P>

<P>//Add text to the shape "Rectangle 2"</P>
<P>Shapes oShapes = oSlide.GetShapes();</P>
<P>Shape oShape = oShapes.Item(COleVariant("Rectangle 2"));</P>
<P>TextFrame oTxtFrm = oShape.GetTextFrame();</P>
<P>TextRange oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("Automating PowerPoint");</P>

<P>//Add text to the shape "Rectangle 3"</P>
<P>oShape = oShapes.Item(COleVariant("Rectangle 3"));</P>
<P>oTxtFrm = oShape.GetTextFrame();</P>
<P>oTxtRng = oTxtFrm.GetTextRange();</P>
<P>oTxtRng.SetText("To Create and View a SlideShow");</P>

<P>//SLIDE #2 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(2, 12); //ppLayoutBlank = 12</P>

<P>//Add a chart to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShape = oShapes.AddOLEObject(20, 20, 660, 500, "MSGraph.Chart", </P>
<P>                              "", 0, "", 0, "", 0);</P>

<P>//Get the Chart object so that you can automate MSGraph</P>
<P>OLEFormat oOLEFmt = oShape.GetOLEFormat();</P>
<P>MSGraph::Chart oChart = oOLEFmt.GetObject();</P>
<P>MSGraph::Application oGraphApp = oChart.GetApplication();</P>

<P>//Modify the chart's datasheet</P>
<P>MSGraph::DataSheet oData = oGraphApp.GetDataSheet();</P>
<P>MSGraph::Range oCells = oData.GetCells();</P>
<P>MSGraph::Range oCell;</P>
<P>COleVariant vCell;</P>
<P>oCells.Delete(vOpt);</P>

<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("John"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)2));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)520));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Sue"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)3));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)660));</P>
<P>vCell = oCells.GetItem(COleVariant((short)1), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant("Bill"));</P>
<P>vCell = oCells.GetItem(COleVariant((short)2), COleVariant((short)4));</P>
<P>oCell.AttachDispatch(vCell.pdispVal);</P>
<P>oCell.SetValue(COleVariant((short)690));</P>

<P>//Set the chart's type</P>
<P>oChart.SetChartType(5); //xlPie = 5</P>

<P>//Remove the border from the plot area</P>
<P>MSGraph::PlotArea oPlot = oChart.GetPlotArea();</P>
<P>MSGraph::Border oBrdr = oPlot.GetBorder();</P>
<P>oBrdr.SetLineStyle(COleVariant((long)-4142));//xlLineStyleNone = 4142</P>

<P>//Position the legend</P>
<P>MSGraph::Legend oLegend = oChart.GetLegend();</P>
<P>oLegend.SetPosition((long)(-4107)); //xlLegendPositionBottom = -4107</P>

<P>//Modify the chart's title</P>
<P>oChart.SetHasTitle(TRUE);</P>
<P>MSGraph::ChartTitle oChartTtl = oChart.GetChartTitle();</P>
<P>oChartTtl.SetText("ACME Corporation");</P>

<P>//Save changes to the chart and close MSGraph</P>
<P>oGraphApp.Update();</P>
<P>oGraphApp.Quit();</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
<P>//SLIDE #3 ======================================================</P>

<P>//Add a blank slide</P>
<P>oSlide = oSlides.Add(3, 12); //ppLayoutBlank = 12</P>

<P>//Add Text Effects to the slide</P>
<P>oShapes = oSlide.GetShapes();</P>
<P>oShapes.AddTextEffect(27,   //msoTextEffect28 = 27</P>
<P>                      "The End","Impact", 100, 0, 0, 200, 200);</P>

<P>&nbsp;</P>
<P>//Apply a color scheme to all slides</P>
<P>SlideRange oSlideRng = oSlides.Range(vOpt);</P>
<P>ColorSchemes oSchemes = oPres.GetColorSchemes();</P>
<P>ColorScheme oScheme = oSchemes.Item(3);</P>
<P>oSlideRng.SetColorScheme(oScheme);</P>

<P>//Set up slide show settings</P>
<P>SlideShowTransition oSST = oSlideRng.GetSlideShowTransition();</P>
<P>oSST.SetEntryEffect(770);   //ppEffectBlindsVertical = 770</P>
<P>oSST.SetAdvanceOnTime(TRUE);</P>
<P>oSST.SetAdvanceTime(3);</P>

<P>//View the show</P>
<P>::Sleep(500);</P>
<P>SlideShowSettings oSSS = oPres.GetSlideShowSettings();</P>
<P>oSSS.SetAdvanceMode(2);     //ppSlideShowUseSlideTimings = 2</P>
<P>SlideShowWindow oShowWindow = oSSS.Run();</P>

<P>//Wait until there are no more slide show windows and then</P>
<P>//quit PowerPoint</P>
<P>SlideShowWindows oShowWindows = oApp.GetSlideShowWindows();</P>
<P>do</P>
<P>{</P>
<P>    ::Sleep(500);</P>
<P>}</P>
<P>while (oShowWindows.GetCount()&gt;0);</P>
<P>oApp.Quit();</P>
<P>::Sleep(100);</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Add the following includes to SlideShowDlg.cpp:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>#include "MSPPT8.h"  // or "MSPPT9.h" for PowerPoint 2000</P>
<P>#include "Graph8.h"  //or "Graph9.h" for Graph 2000</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>Modify <B>CSlideShowApp::InitInstance()</B> in <B>SlideShow.cpp</B> to start COM services:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    if(!AfxOleInit())</P>
<P>    {</P>
<P>        AfxMessageBox("Cannot initialize COM services.");</P>
<P>        return FALSE;</P>
<P>    }</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the application. Click the button you added to the dialog box. The presentation is created on the fly while PowerPoint is hidden and then the slide show runs. When the slide show ends, the presentation closes and PowerPoint quits.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Automate an Office Application to Obtain a Document's Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>Microsoft Office applications create OLE compound documents that store document properties, such as title, subject, author, creation date, and so forth. Each application has its own set of built-in document properties but you can also add your own (custom document properties).  In an Office application's user interface, you can change and view these document properties. To display a document’s properties while in an Office application, on the <B>File</B> menu, click the <B>Properties</B> command and the Properties dialog box appears. You can also access these document properties by automating a Microsoft Office application. The next samples illustrate how to automate Word to retrieve built-in document properties from a Word document. In both samples, you create a dialog that resembles the one illustrated in Figure 19.</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=1><P>Figure 19:   This illustration represents the suggested layout of the form (or dialog box) you create for your sample application to retrieve document properties.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>Visual Basic Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Start a new project in Visual Basic. Form1 is created by default.</LI>
<LI>Add a reference to the Microsoft Word 8.0 (or 9.0) object library.</LI>
<LI>On the <B>Project</B> menu, click <B>Components</B>. Check the <B>Microsoft Common Dialog control</B> and click <B>OK</B>.</LI>
<LI>Add controls to Form1 and set properties for the controls as outlined in the following table. Note that you can use the form illustrated in Figure 19 for a suggested layout.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblFilename</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Label</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>lblValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cboProperty</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Enabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>False</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Style</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>2 – Dropdown List</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=3>
<FONT FACE="Arial" SIZE=2><P>TextBox</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>txtValue</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Locked</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>True</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdSelectFile</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Document…</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>CommandButton</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>cmdClose</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Close</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>CommonDialog</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<LI>In this sample application, you have variables with form-level scope that reference a Word<B> Application</B> object that you reuse for the lifetime of the form, a Word<B> Document</B> object for which you want to retrieve document properties, and a string for the filename of the document you select.<BR>
<BR>
Add the following to the General Declarations section of Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Dim oWordApp As Word.Application</P>
<P>Dim oWordDoc As Word.Document</P>
<P>Dim sFile As String 'Filename of selected file</P>

<P>&nbsp;</P>
</FONT><FONT FACE="Arial" SIZE=2><LI>When the form loads, it starts an instance of Word that it will use for the lifetime of the form. To obtain a list of the built-in document properties that Word documents support and add them to the Combo Box, you can start a new document in Word, iterate its <B>BuiltInDocumentProperties</B> collection, and then close the document because it is no longer needed.<BR>
<BR>
Add the following event handling code to Form1:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdClose_Click()</P>
<P>    Unload Me</P>
<P>End Sub</P>

<P>&nbsp;</P>
<P>Private Sub Form_Load()</P>
<P>    'Start up a new hidden instance of Word</P>
<P>    Set oWordApp = New Word.Application</P>
<P>    </P>
<P>    'Create a new document just so that you can retrieve the list </P>
<P>    ' of built-in document property names and then close the </P>
<P>    'document since it is no longer needed</P>
<P>    Set oWordDoc = oWordApp.Documents.Add</P>
<P>    Dim oProp As Object</P>
<P>    For Each oProp In oWordDoc.BuiltInDocumentProperties</P>
<P>        cboProperty.AddItem oProp.Name</P>
<P>    Next</P>
<P>    oWordDoc.Close SaveChanges:=False</P>
<P>    Set oWordDoc = Nothing</P>
<P>End Sub</P>

<P>Private Sub Form_Unload(Cancel As Integer)</P>
<P>    'Close the open document and quit the instance of Word</P>
<P>    If Not (oWordDoc Is Nothing) Then</P>
<P>       oWordDoc.Close SaveChanges:=False</P>
<P>    End If</P>
<P>    oWordApp.Quit</P>
<P>    Set oWordDoc = Nothing</P>
<P>    Set oWordApp = Nothing</P>
<P>End Sub</P>
</FONT><FONT FACE="Arial" SIZE=2>
<LI>When you click <B>cmdSelectFile</B> at run time, you are prompted to select a .doc file. Once a file is selected, you then open that document in the instance of Word you started in the Form's <B>Load</B> event.<BR>
<BR>
Add the following code to the click event of <B>cmdSelectFile</B>:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cmdSelectFile_Click()</P>
<P>    </P>
<P>    'Use the CommonDialog to allow the user to select a file</P>
<P>    With CommonDialog</P>
<P>        .FileName = ""</P>
<P>        .Filter = "Microsoft Word Document (*.doc)|*.doc"</P>
<P>        .ShowOpen</P>
<P>        sFile = .FileName</P>
<P>    End With</P>
<P>    </P>
<P>    'If a file was selected, then set the caption for lblFilename</P>
<P>    'Close the previously opened Word document (if one was open)</P>
<P>    'and then open the newly selected Word document as read-only</P>
<P>    If sFile &lt;&gt; "" Then</P>
<P>        lblFilename.Caption = sFile</P>
<P>        If Not (oWordDoc Is Nothing) Then</P>
<P>            oWordDoc.Close SaveChanges:=False</P>
<P>            Set oWordDoc = Nothing</P>
<P>        End If</P>
<P>        Set oWordDoc = oWordApp.Documents.Open(FileName:=sFile, _</P>
<P>                                               ReadOnly:=True)</P>
<P>        cboProperty.Enabled = True</P>
<P>        cboProperty.ListIndex = -1</P>
<P>        txtValue.Text = ""</P>
<P>    End If</P>
<P>    </P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a document property in the Combo Box, you query the open document in Word for the value of that property. </LI>
<B><P>NOTE</B>: If Microsoft Word does not define a value for a <B>BuiltinDocumentProperty</B>, reading the <B>Value</B> for that property generates a run-time error, so you must trap for that error and handle it accordingly.<BR>
<BR>
Add the following code to the <B>Click</B> event of the Combo Box <B>cboProperty</B>:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>Private Sub cboProperty_Click()</P>
<P>    'Retrieve the selected document property and add it to </P>
<P>    'the textbox txtValue</P>
<P>    On Error Resume Next</P>
<P>    txtValue.Text = oWordDoc.BuiltInDocumentProperties( _</P>
<P>                            cboProperty.Text).Value</P>
<P>    If Err &lt;&gt; 0 Then</P>
<P>        txtValue.Text = _<BR>
             "&lt;The property you selected is not available&gt;"</P>
<P>    End If</P>
<P>    On Error GoTo 0</P>
<P>End Sub</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>Run the application. Click the button <B>cmdSelectFile</B> and select a Word document. Once you have selected the document, the list of built-in document properties for that document appears in the Combo Box. Select any property in the list and its value appears in the text box. If you select a document property that does not have an associated value, the TextBox displays the message:</LI></OL>
<DIR>
<DIR>
<DIR>

<P> "&lt;The property you selected is not available&gt;."<BR>
</P></DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=2><P>MFC Sample</P></DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Create a new MFC Appwizard EXE that is dialog-based and name it "DocProps.&quot;</LI>
<LI>Using ClassWizard, add all of the classes in the Microsoft Word 8.0 (or 9.0) type Library.</LI>
<LI>Select the dialog resource IDD_DOCPROPS_DIALOG. Change the ID of the IDOK button to IDC_SELECT_DOC, change its caption to <B>Select a Document </B> and deselect the <B>Default button style</B> property.  Change the caption of the IDCANCEL button to <B>Close</B>.</LI>
<LI>Add the following controls to the dialog as well. Use Figure 19 as a suggested layout for your controls.</LI>
</OL>
</FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=481>
<TR><TD WIDTH="25%" VALIGN="TOP">
<B><FONT FACE="Arial" SIZE=2><P>Control Type</B></FONT></TD>
<TD WIDTH="75%" VALIGN="TOP" COLSPAN=2>
<B><FONT FACE="Arial" SIZE=2><P>Property</B></FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_FILENAME</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Select a Word Document</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Name</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Property</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Static Text</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_VALUE_LABEL</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Caption</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Value</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=2>
<FONT FACE="Arial" SIZE=2><P>Combo Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_LIST</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Disabled</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP" ROWSPAN=4>
<FONT FACE="Arial" SIZE=2><P>Edit Box</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>ID</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>IDC_PROPERTY_VALUE</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Read-only</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Auto HScroll</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Unchecked</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Multiline</FONT></TD>
<TD WIDTH="54%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P>Checked</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2>
<B><P>NOTE</B>: The default size of a Combo Box does not provide space for the drop-down portion containing the list. You can resize it by selecting it, then clicking directly on the drop-down arrow at the right side of the box. This provides a vertical resize handle in the center of the edit portion so that you can resize the drop-down portion for the list.</P>
<LI>In DocPropsDlg.h, include the Word wrapper classes: </LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>   </P>
<P>    #include "msword8.h"  //or "msword9.h" for Word 2000</P>

</FONT><FONT FACE="Arial" SIZE=2><P>and add the following data members to the <B>CDocPropsDlg</B> class:</P>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    _Application m_oApp;</P>
<P>    Documents m_oDocs;</P>
<P>    _Document m_oDoc;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog loads, it starts a new Word instance with which you examine document properties. Once Word is started, it creates a new Word document for the sole purpose of extracting a list of built-in document properties to populate the Combo Box. <BR>
<BR>
Add the following code to the <B>CDocPropsDlg::OnInitDialog</B> handler:</LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    HRESULT hr;</P>
<P>    VARIANT vResult;</P>

<P>    //Start Word</P>
<P>    AfxOleInit();</P>
<P>    if(!m_oApp.CreateDispatch("Word.Application", NULL))</P>
<P>    {</P>
<P>        AfxMessageBox("Unable to start Word");</P>
<P>        return false;</P>
<P>    }</P>

<P>    //Create a new document in Word</P>
<P>    m_oDocs = m_oApp.GetDocuments();</P>
<P>    m_oDoc = m_oDocs.Add(vOpt, vOpt);</P>
<P>    </P>
<P>    //Note for Word 2000: The Add method has 4 arguments in Word </P>
<P>    //2000.  If you wrapped the classes from the Word type library </P>
<P>    //(msword9.olb), modify the Add method to provide 4 optional </P>
<P>    //arguments:</P>
<P>    //    oDoc = oDocs.Add(vOpt, vOpt, vOpt, vOpt);  </P>

<P>&nbsp;</P>
<P>    //Get the IDispatch pointer to the BuiltInDocumentProperties </P>
<P>    //collection object</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Retrieve a count of the number of BuiltinDocumentProperties</P>
<P>    //NOTE: The DISPID of the "Count" property of a </P>
<P>    //      DocumentProperties collection is 0x4</P>
<P>    hr = lpdispProps-&gt;Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>            DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, NULL);</P>
<P>    long lPropCount = vResult.lVal;</P>

<P>    CComboBox* pcboPropList = </P>
<P>                 (CComboBox*) GetDlgItem(IDC_PROPERTY_LIST);</P>

<P>    char szPropName[255];</P>

<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_I4;</P>
<P>    vArgs[0].lVal = 0;</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    </P>
<P>    for(long i=1; i&lt;=lPropCount; i++)</P>
<P>    {</P>
<P>        //Retrieve a DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Item" property of a </P>
<P>        //      DocumentProperties object is 0x0</P>
<P>        dpItem.rgvarg[0].lVal = i;</P>
<P>        hr = lpdispProps-&gt;Invoke(0x0, IID_NULL,</P>
<P>                LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &amp;dpItem,</P>
<P>                &amp;vResult, NULL, NULL);</P>
<P> </P>
<P>        //Get the name of the DocumentProperty</P>
<P>        //NOTE: The DISPID of the "Name" property of a </P>
<P>        //      DocumentProperty object is 0x3</P>
<P>        LPDISPATCH lpdispProp = vResult.pdispVal;</P>
<P>        hr = lpdispProp-&gt;Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT,</P>
<P>                DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, NULL, </P>
<P>                NULL);</P>

<P>        //Add the property name to the Combo Box</P>
<P>        wcstombs(szPropName, vResult.bstrVal, 255);</P>
<P>        pcboPropList-&gt;InsertString(-1, szPropName);</P>

<P>        //Release the IDispatch interface for the </P>
<P>        //BuiltinDocumentProperty object</P>
<P>        lpdispProp-&gt;Release();</P>
<P>    }</P>

<P>    //Release the IDispatch interface for the </P>
<P>    //BuiltinDocumentProperties collection</P>
<P>    lpdispProps-&gt;Release();</P>

<P>    //Close the no longer needed document</P>
<P>    m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>    m_oDoc.ReleaseDispatch();</P>
<P>    m_oDoc.m_lpDispatch = NULL;</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When the dialog box appears at run time, you can click <B>Select a Document</B> to select the Word document for which you want to examine document properties. Therefore, the handler for this button displays a Windows Open dialog box to retrieve the full path and filename of the selected Word document, opens the document in the instance of Word you started, closes the previously opened Word document (if any), and enables the Combo Box.<BR>
<BR>
Add the following code to the BN_CLICKED handler of the button IDC_SELECT_DOC: </LI>
</FONT><FONT FACE="Courier New" SIZE=1>
<P>void CDocPropsDlg::OnSelectDoc() </P>
<P>{</P>
<P>    char szFilter[] = "Microsoft Word Document(.doc)|*.doc||";</P>

<P>    CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY |</P>
<P>                        OFN_OVERWRITEPROMPT, szFilter);</P>

<P>    if(dlg.DoModal()==IDOK)</P>
<P>    {</P>
<P>        CString sFile = dlg.GetPathName();</P>
<P>        SetDlgItemText(IDC_FILENAME, sFile);</P>
<P>        CComboBox* pcboPropList = </P>
<P>              (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>        pcboPropList-&gt;EnableWindow(TRUE);</P>

<P>        //Close the previously opened document if one was open and </P>
<P>        //then open the newly selected document as read-only</P>
<P>        COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>        if(m_oDoc.m_lpDispatch!=NULL)</P>
<P>        {</P>
<P>            m_oDoc.Close(COleVariant((short)false), vOpt, vOpt);</P>
<P>            m_oDoc.ReleaseDispatch();</P>
<P>            m_oDoc.m_lpDispatch = NULL;</P>
<P>        }</P>
<P>        m_oDoc = m_oDocs.Open(COleVariant(sFile), vOpt, </P>
<P>                     COleVariant((short)true), vOpt, vOpt, vOpt, </P>
<P>                     vOpt, vOpt, vOpt, vOpt);</P>

<P>        //Note for Word 2000: The Open method has 12 arguments in </P>
<P>        //Word 2000.  If you wrapped the classes from the Word </P>
<P>        //type library (msword9.olb), modify the Open method above</P>
<P>        //so that you are passing two additional optional </P>
<P>        //arguments.</P>

<P>    }</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you select a property name in the combo box, the value corresponding to that property for the open Word document is displayed in the edit box. Add the following code to the CBN_SELCHANGE handler for the IDC_PROPERTY_LIST combo box:</LI>
</FONT><FONT FACE="Courier New" SIZE=1><P>void CDocPropsDlg::OnSelchangePropertyList() </P>
<P>{</P>
<P>    //When the Selection changes, retrieve the value of the </P>
<P>    //selected document property</P>
<P>    CString sProperty;</P>
<P>    CComboBox* pcboPropList = </P>
<P>               (CComboBox*)GetDlgItem(IDC_PROPERTY_LIST);</P>
<P>    pcboPropList-&gt;GetLBText(pcboPropList-&gt;GetCurSel(), sProperty);</P>

<P>    //Get the BuiltinDocumentProperties collection for the </P>
<P>    //document</P>
<P>    LPDISPATCH lpdispProps;</P>
<P>    lpdispProps = m_oDoc.GetBuiltInDocumentProperties();</P>

<P>    //Get the requested Item from the BuiltinDocumentProperties </P>
<P>    //collection</P>
<P>    //NOTE:  The DISPID of the "Item" property of a </P>
<P>    //       DocumentProperties object is 0x0</P>
<P>    VARIANT vResult;</P>
<P>    DISPPARAMS dpItem;</P>
<P>    VARIANT vArgs[1];</P>
<P>    vArgs[0].vt = VT_BSTR;</P>
<P>    vArgs[0].bstrVal = sProperty.AllocSysString();</P>
<P>    dpItem.cArgs=1;</P>
<P>    dpItem.cNamedArgs=0;</P>
<P>    dpItem.rgvarg = vArgs;</P>
<P>    HRESULT hr = lpdispProps-&gt;Invoke(0x0, IID_NULL, </P>
<P>                      LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, </P>
<P>                       &amp;dpItem, &amp;vResult, NULL, NULL);</P>
<P>    ::SysFreeString(vArgs[0].bstrVal);</P>

<P>    //Get the Value property of the BuiltinDocumentProperty</P>
<P>    //NOTE:  The DISPID of the "Value" property of a </P>
<P>    //       DocumentProperty object is 0x0</P>
<P>    DISPPARAMS dpNoArgs = {NULL, NULL, 0, 0};</P>
<P>    LPDISPATCH lpdispProp;</P>
<P>    lpdispProp = vResult.pdispVal;</P>
<P>    hr = lpdispProp-&gt;Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, </P>
<P>                   DISPATCH_PROPERTYGET, &amp;dpNoArgs, &amp;vResult, </P>
<P>                   NULL, NULL);</P>

<P>    //Set the text in the Edit Box to the property's value</P>
<P>    CString sPropValue = "";</P>
<P>    switch (vResult.vt)</P>
<P>    {</P>
<P>    case VT_BSTR:</P>
<P>        sPropValue = vResult.bstrVal;</P>
<P>        break;</P>
<P>    case VT_I4:</P>
<P>        sPropValue.Format("%d",vResult.lVal);</P>
<P>        break;</P>
<P>    case VT_DATE:</P>
<P>        {</P>
<P>            COleDateTime dt (vResult);</P>
<P>            sPropValue = dt.Format(0, LANG_USER_DEFAULT);</P>
<P>            break;</P>
<P>        }</P>
<P>    default:</P>
<P>        sPropValue = "&lt;Information for the property you selected \</P>
<P>                     is not available&gt;";</P>
<P>        break;</P>
<P>    }</P>
<P>    SetDlgItemText(IDC_PROPERTY_VALUE, sPropValue);</P>

<P>    //Release the no longer needed IDispatch pointers</P>
<P>    lpdispProp-&gt;Release();</P>
<P>    lpdispProps-&gt;Release();</P>
<P>}</P>

</FONT><FONT FACE="Arial" SIZE=2><LI>When you click <B>Close</B> in the dialog box, clean up by quitting the instance of Word that you started. Add the following code to the handler for the IDCANCEL button:</LI></OL>

</FONT><FONT FACE="Courier New" SIZE=1><DIR>
<DIR>
<DIR>

<P>void CDocPropsDlg::OnCancel() </P>
<P>{</P>
<P>    //Quit Microsoft Word without saving changes to</P>
<P>    //any open documents</P>
<P>    COleVariant vOpt(DISP_E_PARAMNOTFOUND, VT_ERROR);</P>
<P>    m_oApp.Quit(COleVariant((short)false), vOpt, vOpt);</P>

<P>&#9;CDialog::OnCancel();</P>
<P>}</P>
</DIR>
</DIR>
</DIR>

<OL>

<OL>

</FONT><FONT FACE="Arial" SIZE=2><LI>Build and run the sample application. When the dialog is loaded, click <B>Select a Document</B> and choose any Word document. The document is opened in the hidden instance of Word. Choose a property from the Combo Box, and note that the property's value appears in the Edit Box.</LI></OL>
</OL>

</FONT><FONT FACE="Arial Black" SIZE=2><DIR>

<P>Additional Notes for Working with Office Document Properties</P>
</FONT><FONT FACE="Arial" SIZE=2><P>If you want to see an additional sample for automating an Office application to retrieve document properties (both built-in and custom), please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238393 HOWTO: Use Visual C++ to Access DocumentProperties with Automation <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/3/93.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/3/93.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Note that you can also retrieve document property information without Automation and even without the need for the Office application that created the file. Office documents are OLE compound documents that store document properties in persistent property sets. These property sets are managed by COM/OLE and can be retrieved using the <B>IPropertySetStorage</B> and <B>IPropertyStorage</B> interfaces. For details, see:</P>
<P>Q186898 HOWTO: Read Compound Document Properties Directly with VC++ <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/8/98.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/8/98.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q224351 FILE: DSOFILE.EXE Lets You Read Document Properties w/o Office <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q224/3/51.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q224/3/51.asp</FONT></A></P><DIR>
<DIR>
<DIR>

<FONT FACE="Arial" SIZE=2><P>&#9;</P></DIR>
</DIR>
</DIR>
</DIR>

</FONT><FONT FACE="Arial Black" SIZE=3><P>Troubleshooting Common problems</P>
</FONT><FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
Why does the Automation server remain in memory even after my Automation code ends?</P>
</B><P>There are several potential causes of this problem:</P>

<UL>
<LI>With C/C++ and MFC Automation clients, an unreleased interface pointer is commonly the culprit. Verify that you release acquired interfaces properly before your Automation code ends. Also, check the methods and properties that you are invoking; if you ignore the return value of an invoked method or property that returns an <B>LPDISPATCH</B>, the reference count for the object might not be decremented when your code ends. </LI>
<LI>If you are making the Automation server visible so that the user can interact with the server, insure that you are properly giving the user control of the application before your Automation code ends. Some Automation clients, such as Microsoft Excel, require that you give the user control of the application by setting a property, the <B>UserControl</B> property. When automating Microsoft Excel, if you make the application visible without setting the <B>UserControl</B> property to <B>True</B>, the reference count for the application is not properly decremented.</LI>
<LI>With Visual Basic Automation clients, make sure that you have properly qualified all methods and properties with an object variable that you set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</LI></UL>


<UL>
<LI>If you have Automation code in a tight loop and are requesting close to or more than 64K interfaces, you might be running into a limitation with Windows 95 or Windows 98. To correct this problem, reduce the number of interface requests to avoid hitting the 64K limit for interface requests. For more details, see the section "Improving Your Automation Code: Tip #5 – Minimize Interface Requests" in this document.</LI></UL>

<B>
<P>PROBLEM:<BR>
In my Visual Basic Automation client, I receive the run-time error 429 while attempting to start and attach to the Automation server. What could be wrong?</P>
</B><P>This error is usually caused by a problem with the Automation server installation or a problem with the way that the Automation server is registered. For tips on troubleshooting run-time error 429, see the following article in the Microsoft Knowledge Base:</P>
<P>Q244264 INFO: Troubleshooting Error 429 When Automating Office Applications <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q244/2/64.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q244/2/64.asp</FONT></A></P>
<B><FONT FACE="Arial" SIZE=2>
<P>PROBLEM:<BR>
My Automation code works as expected the first time but fails on the second attempt. What could the problem be?</P>
</B><P>This problem typically occurs in Visual Basic Automation clients in which you have not properly qualified a method or property with an object variable that you have set at run time. For more information on properly qualifying methods and properties, see the section "Creating an Automation Client with Visual Basic" in this document. Also see the following articles in the Microsoft Knowledge Base:<BR>
<BR>
Q189618 PRB: Automation Error Calling Unqualified Method or Property <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q189/6/18.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q189/6/18.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
<BR>
Q178510 PRB: Excel Automation Fails Second Time Code <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q178/5/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q178/5/10.asp</FONT></A><FONT FACE="Arial" SIZE=2><BR>
</P>
<B><P>PROBLEM:<BR>
I am receiving long Automation errors, such as "–2147418094 (80010012)" in my Visual Basic Automation client. What does this error mean?</P>
</B><P>When automating another application with Visual Basic,<B> </B>you might receive an error similar to the following: </P><DIR>
<DIR>

<P>Run-time error '-2147418094 (80010012)':<BR>
Automation Error. </P></DIR>
</DIR>

<P>The value -2147418094 is the decimal representation of the error code; 80010012 is the hexadecimal representation of the same code. Depending on the source of the error (it  is either a COM error or an error generated by the Automation server), it can be interpreted in one of two ways: </P>
<OL>

<OL>

<LI>If it is a COM error, you can use the Error Lookup utility or the <B>FormatMessage</B> API function to retrieve a textual description of the error message. </LI>
<LI>If it is an Automation error returned from the server, it cannot be translated using Error Lookup or <B>FormatMessage</B>. Instead, you need to refer to the documentation for the Automation server. Typically, with application-specific errors, the last four digits of the hexadecimal representation of the error code refer to the application specific error. For example, if you are automating Microsoft Word and you receive an Automation error -2146823136 (0x800a1420), if you convert the last four digits of the hexadecimal value (1420) to decimal, you get 5152. You can then examine the documentation for the server to determine the meaning of run-time error 5152.</LI></OL>
</OL>

<P>For more information on translating Automation errors, see the following articles in the Microsoft Knowledge Base:</P>
<P>Q186063 INFO: Translating Automation Errors for VB/VBA (Long) <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q186/0/63.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q186/0/63.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q238986 INFO: Translating Large Office Automation Error Values <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/q238/9/86.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/q238/9/86.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2><P>Q2244491:  WRD97ERR.DOC Contains a List of Word 97 Automation Errors<BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q244/4/91.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q244/4/91.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I run my Automation code, the server displays a dialog that interrupts code execution and requires user input. How can I avoid this?</P>
</B><P>Most Microsoft Office applications have a <B>DisplayAlerts</B> property that prevents "alert" messages from appearing while your Automation code runs.  Set the <B>DisplayAlerts</B> property of the <B>Application</B> object to <B>False</B> to avoid alert messages. </P>
<P>An example of an alert is a prompt you might receive when you programmatically call a method to save a document to a file that already exists. In this scenario, the prompt you receive is a confirmation that you want to overwrite the file. You can avoid this type of message so that no user intervention is required by setting <B>DisplayAlerts</B> to <B>False</B> and the file is automatically over-written.</P>
<P> </P>
<B><P>PROBLEM:<BR>
My Automation client worked fine with the Office 97 version of my application. However, I rebuilt my project and it works fine with Office 2000 but now fails with Office 97. What could be wrong?</B> </P>
<P>New versions of Office include new features and enhance some of the existing ones. To provide clients with programmatic access to these new and enhanced features, the object models must be updated. Because of this update, a method may have more arguments for Office 2000 than it did with Office 97. </P>
<P>The new arguments to existing methods are usually optional. If you use late binding to the Office Automation server, your code should work successfully with either Office 97 or Office 2000. However, if you use early binding, the differences between the 97 and 2000 type libraries could cause you problems in the following situations:</P>

<UL>
<LI>If you create an Automation client in Visual Basic and reference the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI>
<LI>If you create an MFC Automation client and use the ClassWizard to wrap classes from the Office 2000 type library, your code might fail when using an Office 97 server if you call a method or property that has changed.</LI></UL>

<P>To avoid this problem, you should develop your Automation client against the lowest version of the Office server you intend to support. For the best results in maintaining compatibility with multiple versions of Office, you should use late binding. However, if you choose to use early binding, bind to the type library for the earliest version of the Office server you want to support. To illustrate, if you are writing an Automation client with Visual Basic and want that client to work with Excel 97 and Excel 2000, you should reference the Excel 97 type library in your Visual Basic project. Likewise, if you are writing an Automation client using MFC, you should use the ClassWizard to wrap the Excel 97 type library.</P>
<P>For more information, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q224925 INFO: Type Libraries for Office 2000 Have Changed <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q224/9/25.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q224/9/25.asp</FONT></A></P>
<FONT FACE="Arial" SIZE=2>
<B><P>PROBLEM:<BR>
When I attempt to automate a running instance of an Office application, it fails. What could be wrong?</P>
</B><P>Microsoft Office applications do not immediately register their running objects in the Running Object Table (ROT) as soon as they are started. Instead, a shelled Office application waits to register itself until it has lost focus. It does so to optimize the application's launch process. If you programmatically execute an Office application and then immediately call <B>::GetActiveObject</B> in C/C++ (or <B>GetObject</B> in Visual Basic) to attach to the running instance you just started, the call might fail because the application has not registered. To successfully attach to an instance of an Office application you just executed, force the Office application to lose focus so that it registers its running objects in the ROT. </P>
<P>For more information and sample code, please see the following article in the Microsoft Knowledge Base:</P>
<P>Q238610 PRB: GetObject or GetActiveObject Can't Find a Running Office Application <BR>
</FONT><A HREF="http://support.microsoft.com/support/kb/articles/Q238/6/10.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/kb/articles/Q238/6/10.asp</FONT></A></P>
<FONT FACE="Arial Black" SIZE=3><P>For More Information</P>
</FONT><FONT FACE="Arial" SIZE=2><P>For information and sample code for integrating Office with Visual Basic, Visual C++, Internet Scripts, and other programming languages, please see the following Web sites:</P>

<UL>
<LI></FONT><A HREF="http://support.microsoft.com/support/officedev/offdevout.asp"><FONT FACE="Arial" SIZE=2>http://support.microsoft.com/support/officedev/offdevout.asp</FONT></A></LI>
<FONT FACE="Arial" SIZE=2><LI></FONT><A HREF="http://msdn.microsoft.com/officedev/"><FONT FACE="Arial" SIZE=2>http://msdn.microsoft.com/officedev/</FONT></A></LI></UL>

<FONT FACE="Arial" SIZE=2>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>*** THE END ***</P></FONT></BODY>
</HTML>
